// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file QoSManager.hpp
 * @brief QoS配置管理接口
 * 
 * 本文件提供了FastDDS QoS配置的统一管理接口，支持以下QoS策略：
 * 
 * 1. 可靠性策略 (ReliabilityQosPolicy)
 *    - RELIABLE_RELIABILITY_QOS: 可靠传输，确保消息不丢失
 *    - BEST_EFFORT_RELIABILITY_QOS: 尽力而为传输，可能丢失消息
 * 
 * 2. 持久性策略 (DurabilityQosPolicy)
 *    - VOLATILE_DURABILITY_QOS: 易失性，新订阅者不会收到历史消息
 *    - TRANSIENT_LOCAL_DURABILITY_QOS: 本地临时，新订阅者会收到本地历史消息
 *    - TRANSIENT_DURABILITY_QOS: 临时，新订阅者会收到全局历史消息
 *    - PERSISTENT_DURABILITY_QOS: 持久，消息会保存到磁盘
 * 
 * 3. 活跃性策略 (LivelinessQosPolicy)
 *    - AUTOMATIC_LIVELINESS_QOS: 自动活跃性，系统自动检测
 *    - MANUAL_BY_PARTICIPANT_LIVELINESS_QOS: 参与者手动，参与者负责声明活跃性
 *    - MANUAL_BY_TOPIC_LIVELINESS_QOS: 主题手动，DataWriter负责声明活跃性
 * 
 * 4. 所有权策略 (OwnershipQosPolicy)
 *    - SHARED_OWNERSHIP_QOS: 共享所有权，多个发布者可以同时发布
 *    - EXCLUSIVE_OWNERSHIP_QOS: 独占所有权，只有强度最高的发布者可以发布
 * 
 * 5. 发布模式策略 (PublishModeQosPolicy)
 *    - SYNCHRONOUS_PUBLISH_MODE: 同步发布，阻塞直到消息被确认
 *    - ASYNCHRONOUS_PUBLISH_MODE: 异步发布，非阻塞
 * 
 * 边界测试建议：
 * - 历史深度：测试0, 1, 1000, 10000等边界值
 * - 资源限制：测试max_samples=1, 1000000等极端值
 * - 时间参数：测试0秒、1纳秒、1小时等边界时间
 * - 可靠性：在BEST_EFFORT模式下测试网络丢包场景
 * - 活跃性：测试租约时间过短导致频繁断开重连
 */

#ifndef QOSMANAGER_HPP
#define QOSMANAGER_HPP

#include <fastdds/dds/domain/qos/DomainParticipantQos.hpp>
#include <fastdds/dds/topic/qos/TopicQos.hpp>
#include <fastdds/dds/publisher/qos/PublisherQos.hpp>
#include <fastdds/dds/publisher/qos/DataWriterQos.hpp>
#include <fastdds/dds/subscriber/qos/SubscriberQos.hpp>
#include <fastdds/dds/subscriber/qos/DataReaderQos.hpp>
#include <fastdds/rtps/common/Time_t.hpp>
#include <vector>
#include <string>

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;

/**
 * @brief QoS配置结构体
 * 
 * 包含所有可配置的QoS参数，分为四个主要类别：
 * - Topic QoS: 主题级别的QoS设置
 * - Publisher/Subscriber QoS: 发布者/订阅者级别的QoS设置
 * - DataWriter QoS: 数据写入者级别的QoS设置
 * - DataReader QoS: 数据读取者级别的QoS设置
 */
struct QoSConfig
{
    /**
     * @brief Topic QoS配置
     * 
     * 控制主题级别的QoS参数，影响所有使用该主题的发布者和订阅者
     */
    struct TopicQoSConfig
    {
        std::vector<uint8_t> topic_data = {5, 6, 7, 8};  // 主题数据，用于过滤和路由
        
        // 历史策略：控制样本的保存方式
        // 可选项：KEEP_LAST_HISTORY_QOS, KEEP_ALL_HISTORY_QOS
        HistoryQosPolicyKind history_kind = KEEP_LAST_HISTORY_QOS;
        
        // 历史深度：保存的样本数量
        // 边界测试建议：0, 1, 100, 1000, 10000, 1000000
        int32_t history_depth = 30;
        
        // 资源限制：控制内存使用
        // 边界测试建议：max_samples=1, 1000000; allocated_samples=0, 1000000
        int32_t max_samples = 50;                    // 最大样本数
        int32_t allocated_samples = 20;              // 预分配样本数
        int32_t allocated_instances = 5;             // 预分配实例数
        int32_t max_samples_per_instance = 30;       // 每个实例的最大样本数
        int32_t max_instances = 10;                  // 最大实例数
        int32_t allocated_samples_per_instance = 50; // 每个实例的预分配样本数
        
        // 持久性策略：控制样本的持久化级别
        // 可选项：VOLATILE_DURABILITY_QOS, TRANSIENT_LOCAL_DURABILITY_QOS, 
        //         TRANSIENT_DURABILITY_QOS, PERSISTENT_DURABILITY_QOS
        DurabilityQosPolicyKind durability_kind = TRANSIENT_LOCAL_DURABILITY_QOS;
        
        // 持久性服务配置：控制持久化服务的参数
        HistoryQosPolicyKind durability_service_history_kind = KEEP_LAST_HISTORY_QOS;
        int32_t durability_service_history_depth = 1;
        int32_t durability_service_max_samples = 200;
        int32_t durability_service_max_instances = 40;
        int32_t durability_service_max_samples_per_instance = 50;
    };

    /**
     * @brief Publisher/Subscriber QoS配置
     * 
     * 控制发布者和订阅者级别的QoS参数
     */
    struct PubSubQoSConfig
    {
        std::string partition_name = "partition_name";  // 分区名称，用于隔离通信
        std::vector<uint8_t> group_data = {9, 10, 11, 12};  // 组数据
        
        // 表示策略：控制样本的表示方式
        // 可选项：INSTANCE_PRESENTATION_QOS, TOPIC_PRESENTATION_QOS, GROUP_PRESENTATION_QOS
        PresentationQosPolicyAccessScopeKind presentation_access_scope = INSTANCE_PRESENTATION_QOS;
        bool coherent_access = false;    // 一致性访问
        bool ordered_access = false;     // 有序访问
    };

    /**
     * @brief DataWriter QoS配置
     * 
     * 控制数据写入者级别的QoS参数
     */
    struct DataWriterQoSConfig
    {
        // 可靠性策略：控制数据传输的可靠性
        // 可选项：RELIABLE_RELIABILITY_QOS, BEST_EFFORT_RELIABILITY_QOS
        // 边界测试：BEST_EFFORT模式下测试网络丢包、延迟等场景
        ReliabilityQosPolicyKind reliability_kind = RELIABLE_RELIABILITY_QOS;
        
        // 生命周期：控制样本的有效期
        // 边界测试：0秒、1纳秒、1小时、c_TimeInfinite
        Duration_t lifespan_duration = c_TimeInfinite;
        
        // 截止时间：控制样本的截止时间
        // 边界测试：0秒、1纳秒、1小时、c_TimeInfinite
        Duration_t deadline_period = c_TimeInfinite;
        
        // 延迟预算：控制传输延迟的预算
        // 边界测试：0秒、1纳秒、1小时
        Duration_t latency_budget_duration = c_TimeZero;
        
        // 所有权策略：控制数据的所有权
        // 可选项：SHARED_OWNERSHIP_QOS, EXCLUSIVE_OWNERSHIP_QOS
        // 边界测试：EXCLUSIVE模式下测试多个发布者的强度竞争
        OwnershipQosPolicyKind ownership_kind = SHARED_OWNERSHIP_QOS;
        int32_t ownership_strength = 0;  // 所有权强度，仅在EXCLUSIVE模式下有效
        
        // 活跃性策略：控制实体的活跃性检测
        // 可选项：AUTOMATIC_LIVELINESS_QOS, MANUAL_BY_PARTICIPANT_LIVELINESS_QOS, MANUAL_BY_TOPIC_LIVELINESS_QOS
        // 边界测试：租约时间过短（如1纳秒）导致频繁断开重连
        LivelinessQosPolicyKind liveliness_kind = AUTOMATIC_LIVELINESS_QOS;
        Duration_t liveliness_lease_duration = c_TimeInfinite;
        
        std::vector<uint8_t> user_data = {1, 2, 3, 4};  // 用户数据
        
        // 发布模式：控制发布的方式
        // 可选项：SYNCHRONOUS_PUBLISH_MODE, ASYNCHRONOUS_PUBLISH_MODE
        // 边界测试：ASYNCHRONOUS模式下测试高频率发布
        PublishModeQosPolicyKind publish_mode_kind = SYNCHRONOUS_PUBLISH_MODE;
        
        // 禁用正确认认：控制确认机制
        // 边界测试：启用时测试网络不稳定场景
        bool disable_positive_acks_enabled = false;
        Duration_t disable_positive_acks_duration = c_TimeInfinite;
        
        // 新增QoS策略字段
        DestinationOrderQosPolicyKind destination_order_kind = BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS;
        int32_t transport_priority = 0;
        DataRepresentationId_t data_representation = XCDR_DATA_REPRESENTATION;
        TypeConsistencyKind type_consistency_kind = DISALLOW_TYPE_COERCION;
        bool autodispose_unregistered_instances = true;
        Duration_t autopurge_disposed_samples_delay = c_TimeInfinite;
    };

    /**
     * @brief DataReader QoS配置
     * 
     * 控制数据读取者级别的QoS参数
     */
    struct DataReaderQoSConfig
    {
        // 可靠性策略：必须与DataWriter匹配
        ReliabilityQosPolicyKind reliability_kind = RELIABLE_RELIABILITY_QOS;
        
        // 生命周期：控制样本的有效期
        Duration_t lifespan_duration = c_TimeInfinite;
        
        // 截止时间：控制样本的截止时间
        Duration_t deadline_period = c_TimeInfinite;
        
        // 延迟预算：控制传输延迟的预算
        Duration_t latency_budget_duration = c_TimeZero;
        
        // 所有权策略：必须与DataWriter匹配
        OwnershipQosPolicyKind ownership_kind = SHARED_OWNERSHIP_QOS;
        
        // 活跃性策略：必须与DataWriter匹配
        LivelinessQosPolicyKind liveliness_kind = AUTOMATIC_LIVELINESS_QOS;
        Duration_t liveliness_lease_duration = c_TimeInfinite;
        
        // 基于时间的过滤：控制样本的时间过滤
        // 边界测试：0纳秒、1纳秒、1秒、1小时
        Duration_t time_based_filter_minimum_separation = c_TimeZero;
        
        std::vector<uint8_t> user_data = {1, 2, 3, 4};  // 用户数据
        
        // 禁用正确认认：控制确认机制
        bool disable_positive_acks_enabled = false;
        Duration_t disable_positive_acks_duration = c_TimeInfinite;
        
        // 新增QoS策略字段
        DestinationOrderQosPolicyKind destination_order_kind = BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS;
        DataRepresentationId_t data_representation = XCDR_DATA_REPRESENTATION;
        TypeConsistencyKind type_consistency_kind = DISALLOW_TYPE_COERCION;
        Duration_t autopurge_nowriter_samples_delay = c_TimeInfinite;
        Duration_t autopurge_disposed_samples_delay = c_TimeInfinite;
        bool enable_invalid_samples = false;
    };

    TopicQoSConfig topic_qos;
    PubSubQoSConfig pubsub_qos;
    DataWriterQoSConfig writer_qos;
    DataReaderQoSConfig reader_qos;
};

/**
 * @brief QoS管理类
 * 
 * 提供统一的QoS配置管理接口，支持：
 * 1. 完整的QoS配置设置和获取
 * 2. 各种QoS策略的应用
 * 3. 便捷的单个参数修改方法
 * 4. 边界测试支持
 */
class QoSManager
{
private:
    QoSConfig config_;

public:
    QoSManager() = default;
    ~QoSManager() = default;

    /**
     * @brief 设置QoS配置
     * @param config 新的QoS配置
     */
    void setQoSConfig(const QoSConfig& config);

    /**
     * @brief 获取当前QoS配置
     * @return 当前QoS配置
     */
    const QoSConfig& getQoSConfig() const;

    /**
     * @brief 应用Topic QoS配置
     * @param tqos 要配置的TopicQos对象
     */
    void applyTopicQoS(TopicQos& tqos) const;

    /**
     * @brief 应用Publisher QoS配置
     * @param pqos 要配置的PublisherQos对象
     */
    void applyPublisherQoS(PublisherQos& pqos) const;

    /**
     * @brief 应用Subscriber QoS配置
     * @param sqos 要配置的SubscriberQos对象
     */
    void applySubscriberQoS(SubscriberQos& sqos) const;

    /**
     * @brief 应用DataWriter QoS配置
     * @param wqos 要配置的DataWriterQos对象
     */
    void applyDataWriterQoS(DataWriterQos& wqos) const;

    /**
     * @brief 应用DataReader QoS配置
     * @param rqos 要配置的DataReaderQos对象
     */
    void applyDataReaderQoS(DataReaderQos& rqos) const;

    // ========== 便捷的配置修改方法 ==========
    
    /**
     * @brief 设置Topic历史深度
     * @param depth 历史深度
     * 边界测试建议：0, 1, 100, 1000, 10000, 1000000
     */
    void setTopicHistoryDepth(int32_t depth);
    
    /**
     * @brief 设置Topic持久性
     * @param kind 持久性类型
     * 可选项：VOLATILE_DURABILITY_QOS, TRANSIENT_LOCAL_DURABILITY_QOS, 
     *         TRANSIENT_DURABILITY_QOS, PERSISTENT_DURABILITY_QOS
     */
    void setTopicDurability(DurabilityQosPolicyKind kind);
    
    /**
     * @brief 设置可靠性
     * @param kind 可靠性类型
     * 可选项：RELIABLE_RELIABILITY_QOS, BEST_EFFORT_RELIABILITY_QOS
     * 边界测试：BEST_EFFORT模式下测试网络丢包场景
     */
    void setReliability(ReliabilityQosPolicyKind kind);
    
    /**
     * @brief 设置活跃性
     * @param kind 活跃性类型
     * @param lease_duration 租约时间
     * 可选项：AUTOMATIC_LIVELINESS_QOS, MANUAL_BY_PARTICIPANT_LIVELINESS_QOS, MANUAL_BY_TOPIC_LIVELINESS_QOS
     * 边界测试：租约时间过短（如1纳秒）导致频繁断开重连
     */
    void setLiveliness(LivelinessQosPolicyKind kind, const Duration_t& lease_duration);
    
    /**
     * @brief 设置分区名称
     * @param partition_name 分区名称
     */
    void setPartition(const std::string& partition_name);
    
    /**
     * @brief 设置用户数据
     * @param user_data 用户数据
     */
    void setUserData(const std::vector<uint8_t>& user_data);
    
    /**
     * @brief 设置截止时间
     * @param period 截止时间周期
     * 边界测试：0秒、1纳秒、1小时、c_TimeInfinite
     */
    void setDeadline(const Duration_t& period);
    
    /**
     * @brief 设置生命周期
     * @param duration 生命周期持续时间
     * 边界测试：0秒、1纳秒、1小时、c_TimeInfinite
     */
    void setLifespan(const Duration_t& duration);
    
    /**
     * @brief 设置延迟预算
     * @param duration 延迟预算时间
     * 边界测试：0秒、1纳秒、1小时
     */
    void setLatencyBudget(const Duration_t& duration);
    
    /**
     * @brief 设置所有权
     * @param kind 所有权类型
     * @param strength 所有权强度（仅在EXCLUSIVE模式下有效）
     * 可选项：SHARED_OWNERSHIP_QOS, EXCLUSIVE_OWNERSHIP_QOS
     * 边界测试：EXCLUSIVE模式下测试多个发布者的强度竞争
     */
    void setOwnership(OwnershipQosPolicyKind kind, int32_t strength = 0);
    
    /**
     * @brief 设置发布模式
     * @param kind 发布模式类型
     * 可选项：SYNCHRONOUS_PUBLISH_MODE, ASYNCHRONOUS_PUBLISH_MODE
     * 边界测试：ASYNCHRONOUS模式下测试高频率发布
     */
    void setPublishMode(PublishModeQosPolicyKind kind);
    
    /**
     * @brief 设置基于时间的过滤
     * @param minimum_separation 最小分离时间
     * 边界测试：0纳秒、1纳秒、1秒、1小时
     */
    void setTimeBasedFilter(const Duration_t& minimum_separation);
    
    /**
     * @brief 设置禁用正确认认
     * @param enabled 是否启用
     * @param duration 持续时间
     */
    void setDisablePositiveAcks(bool enabled, const Duration_t& duration = c_TimeInfinite);

    /**
     * @brief 设置资源限制策略
     * @param max_samples 最大样本数
     * @param max_instances 最大实例数
     * @param max_samples_per_instance 每个实例的最大样本数
     */
    void setResourceLimits(int32_t max_samples, int32_t max_instances, int32_t max_samples_per_instance);

    /**
     * @brief 设置资源分配策略
     * @param allocated_samples 预分配样本数
     * @param allocated_instances 预分配实例数
     * @param allocated_samples_per_instance 每个实例的预分配样本数
     */
    void setResourceAllocation(int32_t allocated_samples, int32_t allocated_instances, int32_t allocated_samples_per_instance);

    /**
     * @brief 设置最大样本数
     * @param max_samples 最大样本数
     */
    void setMaxSamples(int32_t max_samples);

    /**
     * @brief 设置最大实例数
     * @param max_instances 最大实例数
     */
    void setMaxInstances(int32_t max_instances);

    /**
     * @brief 设置每个实例的最大样本数
     * @param max_samples_per_instance 每个实例的最大样本数
     */
    void setMaxSamplesPerInstance(int32_t max_samples_per_instance);

    /**
     * @brief 设置预分配样本数
     * @param allocated_samples 预分配样本数
     */
    void setAllocatedSamples(int32_t allocated_samples);

    /**
     * @brief 设置预分配实例数
     * @param allocated_instances 预分配实例数
     */
    void setAllocatedInstances(int32_t allocated_instances);

    /**
     * @brief 设置每个实例的预分配样本数
     * @param allocated_samples_per_instance 每个实例的预分配样本数
     */
    void setAllocatedSamplesPerInstance(int32_t allocated_samples_per_instance);

    // ========== 新增QoS策略方法 ==========
    
    /**
     * @brief 设置主题数据
     * @param topic_data 主题数据
     */
    void setTopicData(const std::vector<uint8_t>& topic_data);
    
    /**
     * @brief 设置组数据
     * @param group_data 组数据
     */
    void setGroupData(const std::vector<uint8_t>& group_data);
    
    /**
     * @brief 设置表示策略
     * @param access_scope 访问范围
     * @param coherent_access 一致性访问
     * @param ordered_access 有序访问
     */
    void setPresentation(PresentationQosPolicyAccessScopeKind access_scope, bool coherent_access, bool ordered_access);
    
    /**
     * @brief 设置目标顺序策略
     * @param kind 目标顺序类型
     */
    void setDestinationOrder(DestinationOrderQosPolicyKind kind);
    
    /**
     * @brief 设置传输优先级
     * @param priority 优先级值
     */
    void setTransportPriority(int32_t priority);
    
    /**
     * @brief 设置持久性服务
     * @param history_kind 历史策略类型
     * @param history_depth 历史深度
     * @param max_samples 最大样本数
     * @param max_instances 最大实例数
     * @param max_samples_per_instance 每个实例的最大样本数
     */
    void setDurabilityService(HistoryQosPolicyKind history_kind, int32_t history_depth, 
                             int32_t max_samples, int32_t max_instances, int32_t max_samples_per_instance);
    
    /**
     * @brief 设置数据表示
     * @param representation 数据表示类型
     */
    void setDataRepresentation(DataRepresentationId_t representation);
    
    /**
     * @brief 设置类型一致性强制
     * @param kind 类型一致性类型
     */
    void setTypeConsistencyEnforcement(TypeConsistencyKind kind);
    
    /**
     * @brief 设置写入者数据生命周期
     * @param autodispose_unregistered_instances 是否自动处理未注册实例
     * @param autopurge_disposed_samples_delay 自动清理延迟
     */
    void setWriterDataLifecycle(bool autodispose_unregistered_instances, const Duration_t& autopurge_disposed_samples_delay);
    
    /**
     * @brief 设置读取者数据生命周期
     * @param autopurge_nowriter_samples_delay 无写入者时的自动清理延迟
     * @param autopurge_disposed_samples_delay 已处理样本的自动清理延迟
     * @param enable_invalid_samples 是否启用无效样本
     */
    void setReaderDataLifecycle(const Duration_t& autopurge_nowriter_samples_delay, 
                               const Duration_t& autopurge_disposed_samples_delay, 
                               bool enable_invalid_samples);
};

#endif // QOSMANAGER_HPP 