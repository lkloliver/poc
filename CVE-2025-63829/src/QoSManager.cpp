// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file QoSManager.cpp
 * @brief QoS configuration management interface implementation
 */

#include "QoSManager.hpp"
#include <iostream>

void QoSManager::setQoSConfig(const QoSConfig& config)
{
    config_ = config;
}

const QoSConfig& QoSManager::getQoSConfig() const
{
    return config_;
}

void QoSManager::applyTopicQoS(TopicQos& tqos) const
{
    tqos.topic_data().setValue(config_.topic_qos.topic_data);
    tqos.history().kind = config_.topic_qos.history_kind;
    tqos.history().depth = config_.topic_qos.history_depth;
    tqos.resource_limits().max_samples = config_.topic_qos.max_samples;
    tqos.resource_limits().allocated_samples = config_.topic_qos.allocated_samples;
    tqos.resource_limits().max_instances = config_.topic_qos.max_instances;
    tqos.resource_limits().max_samples_per_instance = config_.topic_qos.max_samples_per_instance;
    tqos.durability().kind = config_.topic_qos.durability_kind;
    tqos.durability_service().history_kind = config_.topic_qos.durability_service_history_kind;
    tqos.durability_service().history_depth = config_.topic_qos.durability_service_history_depth;
    tqos.durability_service().max_samples = config_.topic_qos.durability_service_max_samples;
    tqos.durability_service().max_instances = config_.topic_qos.durability_service_max_instances;
    tqos.durability_service().max_samples_per_instance = config_.topic_qos.durability_service_max_samples_per_instance;
}

void QoSManager::applyPublisherQoS(PublisherQos& pqos) const
{
    pqos.partition().clear();
    pqos.partition().push_back(config_.pubsub_qos.partition_name.c_str());
    pqos.group_data().setValue(config_.pubsub_qos.group_data);
    pqos.presentation().access_scope = config_.pubsub_qos.presentation_access_scope;
    pqos.presentation().coherent_access = config_.pubsub_qos.coherent_access;
    pqos.presentation().ordered_access = config_.pubsub_qos.ordered_access;
}

void QoSManager::applySubscriberQoS(SubscriberQos& sqos) const
{
    sqos.partition().clear();
    sqos.partition().push_back(config_.pubsub_qos.partition_name.c_str());
    sqos.group_data().setValue(config_.pubsub_qos.group_data);
    sqos.presentation().access_scope = config_.pubsub_qos.presentation_access_scope;
    sqos.presentation().coherent_access = config_.pubsub_qos.coherent_access;
    sqos.presentation().ordered_access = config_.pubsub_qos.ordered_access;
}

void QoSManager::applyDataWriterQoS(DataWriterQos& wqos) const
{
    std::cout << "  [QoS] Start applying DataWriter QoS configuration..." << std::endl;
    
    std::cout << "  [QoS] 1. Set reliability policy..." << std::endl;
    wqos.reliability().kind = config_.writer_qos.reliability_kind;
    
    std::cout << "  [QoS] 2. Set lifespan..." << std::endl;
    wqos.lifespan().duration = config_.writer_qos.lifespan_duration;
    
    std::cout << "  [QoS] 3. Set deadline..." << std::endl;
    wqos.deadline().period = config_.writer_qos.deadline_period;
    
    std::cout << "  [QoS] 4. Set latency budget..." << std::endl;
    wqos.latency_budget().duration = config_.writer_qos.latency_budget_duration;
    
    // Temporarily commented out QoS policies that may have issues
    std::cout << "  [QoS] 5. Ownership policy..." << std::endl;
    wqos.ownership().kind = config_.writer_qos.ownership_kind;
    wqos.ownership_strength().value = config_.writer_qos.ownership_strength;
    
    std::cout << "  [QoS] 6. Set liveliness policy..." << std::endl;
    wqos.liveliness().kind = config_.writer_qos.liveliness_kind;
    wqos.liveliness().lease_duration = config_.writer_qos.liveliness_lease_duration;
    // Ensure announcement_period is less than lease_duration to avoid QoS check errors
    if (config_.writer_qos.liveliness_lease_duration < c_TimeInfinite)
    {
        wqos.liveliness().announcement_period = Duration_t(
            config_.writer_qos.liveliness_lease_duration.seconds / 2, 
            config_.writer_qos.liveliness_lease_duration.nanosec / 2
        );
    }
    
    std::cout << "  [QoS] 7. Set user data..." << std::endl;
    wqos.user_data().setValue(config_.writer_qos.user_data);
    
    std::cout << "  [QoS] 8. Set publish mode..." << std::endl;
    wqos.publish_mode().kind = config_.writer_qos.publish_mode_kind;
    
    std::cout << "  [QoS] 9. Set data representation..." << std::endl;
    wqos.representation().m_value.push_back(config_.writer_qos.data_representation);
    
    std::cout << "  [QoS] 10. Set data sharing..." << std::endl;
    wqos.data_sharing().automatic();
    
    std::cout << "  [QoS] 11. Set disable positive acks..." << std::endl;
    wqos.reliable_writer_qos().disable_positive_acks.enabled = config_.writer_qos.disable_positive_acks_enabled;
    wqos.reliable_writer_qos().disable_positive_acks.duration = config_.writer_qos.disable_positive_acks_duration;
    
    std::cout << "  [QoS] 12. Set destination order..." << std::endl;
    wqos.destination_order().kind = config_.writer_qos.destination_order_kind;
    
    std::cout << "  [QoS] 13. Set transport priority..." << std::endl;
    wqos.transport_priority().value = config_.writer_qos.transport_priority;
    
    std::cout << "  [QoS] DataWriter QoS configuration applied successfully" << std::endl;
}

void QoSManager::applyDataReaderQoS(DataReaderQos& rqos) const
{
    rqos.reliability().kind = config_.reader_qos.reliability_kind;
    rqos.lifespan().duration = config_.reader_qos.lifespan_duration;
    rqos.deadline().period = config_.reader_qos.deadline_period;
    rqos.latency_budget().duration = config_.reader_qos.latency_budget_duration;
    rqos.ownership().kind = config_.reader_qos.ownership_kind;
    rqos.liveliness().kind = config_.reader_qos.liveliness_kind;
    rqos.liveliness().lease_duration = config_.reader_qos.liveliness_lease_duration;
    rqos.time_based_filter().minimum_separation = config_.reader_qos.time_based_filter_minimum_separation;
    rqos.user_data().setValue(config_.reader_qos.user_data);
    rqos.representation().m_value.push_back(config_.reader_qos.data_representation);
    rqos.data_sharing().off();
    rqos.reliable_reader_qos().disable_positive_acks.enabled = config_.reader_qos.disable_positive_acks_enabled;
    rqos.reliable_reader_qos().disable_positive_acks.duration = config_.reader_qos.disable_positive_acks_duration;
    
    // Apply new QoS policies
    rqos.destination_order().kind = config_.reader_qos.destination_order_kind;
}

// Convenient configuration modification method implementation
void QoSManager::setTopicHistoryDepth(int32_t depth)
{
    config_.topic_qos.history_depth = depth;
}

void QoSManager::setTopicDurability(DurabilityQosPolicyKind kind)
{
    config_.topic_qos.durability_kind = kind;
}

void QoSManager::setReliability(ReliabilityQosPolicyKind kind)
{
    config_.writer_qos.reliability_kind = kind;
    config_.reader_qos.reliability_kind = kind;
}

void QoSManager::setLiveliness(LivelinessQosPolicyKind kind, const Duration_t& lease_duration)
{
    config_.writer_qos.liveliness_kind = kind;
    config_.writer_qos.liveliness_lease_duration = lease_duration;
    config_.reader_qos.liveliness_kind = kind;
    config_.reader_qos.liveliness_lease_duration = lease_duration;
}

void QoSManager::setPartition(const std::string& partition_name)
{
    config_.pubsub_qos.partition_name = partition_name;
}

void QoSManager::setUserData(const std::vector<uint8_t>& user_data)
{
    config_.writer_qos.user_data = user_data;
    config_.reader_qos.user_data = user_data;
}

void QoSManager::setDeadline(const Duration_t& period)
{
    config_.writer_qos.deadline_period = period;
    config_.reader_qos.deadline_period = period;
}

void QoSManager::setLifespan(const Duration_t& duration)
{
    config_.writer_qos.lifespan_duration = duration;
    config_.reader_qos.lifespan_duration = duration;
}

void QoSManager::setLatencyBudget(const Duration_t& duration)
{
    config_.writer_qos.latency_budget_duration = duration;
    config_.reader_qos.latency_budget_duration = duration;
}

void QoSManager::setOwnership(OwnershipQosPolicyKind kind, int32_t strength)
{
    config_.writer_qos.ownership_kind = kind;
    config_.writer_qos.ownership_strength = strength;
    config_.reader_qos.ownership_kind = kind;
}

void QoSManager::setPublishMode(PublishModeQosPolicyKind kind)
{
    config_.writer_qos.publish_mode_kind = kind;
}

void QoSManager::setTimeBasedFilter(const Duration_t& minimum_separation)
{
    config_.reader_qos.time_based_filter_minimum_separation = minimum_separation;
}

void QoSManager::setDisablePositiveAcks(bool enabled, const Duration_t& duration)
{
    config_.writer_qos.disable_positive_acks_enabled = enabled;
    config_.writer_qos.disable_positive_acks_duration = duration;
    config_.reader_qos.disable_positive_acks_enabled = enabled;
    config_.reader_qos.disable_positive_acks_duration = duration;
} 

// ResourceLimitsQosPolicy related method implementation
void QoSManager::setResourceLimits(int32_t max_samples, int32_t max_instances, int32_t max_samples_per_instance)
{
    config_.topic_qos.max_samples = max_samples;
    config_.topic_qos.max_instances = max_instances;
    config_.topic_qos.max_samples_per_instance = max_samples_per_instance;
}

void QoSManager::setResourceAllocation(int32_t allocated_samples, int32_t allocated_instances, int32_t allocated_samples_per_instance)
{
    config_.topic_qos.allocated_samples = allocated_samples;
    config_.topic_qos.allocated_instances = allocated_instances;
    config_.topic_qos.allocated_samples_per_instance = allocated_samples_per_instance;
}

void QoSManager::setMaxSamples(int32_t max_samples)
{
    config_.topic_qos.max_samples = max_samples;
}

void QoSManager::setMaxInstances(int32_t max_instances)
{
    config_.topic_qos.max_instances = max_instances;
}

void QoSManager::setMaxSamplesPerInstance(int32_t max_samples_per_instance)
{
    config_.topic_qos.max_samples_per_instance = max_samples_per_instance;
}

void QoSManager::setAllocatedSamples(int32_t allocated_samples)
{
    config_.topic_qos.allocated_samples = allocated_samples;
}

void QoSManager::setAllocatedInstances(int32_t allocated_instances)
{
    config_.topic_qos.allocated_instances = allocated_instances;
}

void QoSManager::setAllocatedSamplesPerInstance(int32_t allocated_samples_per_instance)
{
    config_.topic_qos.allocated_samples_per_instance = allocated_samples_per_instance;
}

// ========== New QoS policy method implementation ==========

void QoSManager::setTopicData(const std::vector<uint8_t>& topic_data)
{
    config_.topic_qos.topic_data = topic_data;
}

void QoSManager::setGroupData(const std::vector<uint8_t>& group_data)
{
    config_.pubsub_qos.group_data = group_data;
}

void QoSManager::setPresentation(PresentationQosPolicyAccessScopeKind access_scope, bool coherent_access, bool ordered_access)
{
    config_.pubsub_qos.presentation_access_scope = access_scope;
    config_.pubsub_qos.coherent_access = coherent_access;
    config_.pubsub_qos.ordered_access = ordered_access;
}

void QoSManager::setDestinationOrder(DestinationOrderQosPolicyKind kind)
{
    config_.writer_qos.destination_order_kind = kind;
    config_.reader_qos.destination_order_kind = kind;
}

void QoSManager::setTransportPriority(int32_t priority)
{
    config_.writer_qos.transport_priority = priority;
}

void QoSManager::setDurabilityService(HistoryQosPolicyKind history_kind, int32_t history_depth, 
                                     int32_t max_samples, int32_t max_instances, int32_t max_samples_per_instance)
{
    config_.topic_qos.durability_service_history_kind = history_kind;
    config_.topic_qos.durability_service_history_depth = history_depth;
    config_.topic_qos.durability_service_max_samples = max_samples;
    config_.topic_qos.durability_service_max_instances = max_instances;
    config_.topic_qos.durability_service_max_samples_per_instance = max_samples_per_instance;
}

void QoSManager::setDataRepresentation(DataRepresentationId_t representation)
{
    config_.writer_qos.data_representation = representation;
    config_.reader_qos.data_representation = representation;
}

void QoSManager::setTypeConsistencyEnforcement(TypeConsistencyKind kind)
{
    config_.writer_qos.type_consistency_kind = kind;
    config_.reader_qos.type_consistency_kind = kind;
}

void QoSManager::setWriterDataLifecycle(bool autodispose_unregistered_instances, const Duration_t& autopurge_disposed_samples_delay)
{
    config_.writer_qos.autodispose_unregistered_instances = autodispose_unregistered_instances;
    config_.writer_qos.autopurge_disposed_samples_delay = autopurge_disposed_samples_delay;
}

void QoSManager::setReaderDataLifecycle(const Duration_t& autopurge_nowriter_samples_delay, 
                                       const Duration_t& autopurge_disposed_samples_delay, 
                                       bool enable_invalid_samples)
{
    config_.reader_qos.autopurge_nowriter_samples_delay = autopurge_nowriter_samples_delay;
    config_.reader_qos.autopurge_disposed_samples_delay = autopurge_disposed_samples_delay;
    config_.reader_qos.enable_invalid_samples = enable_invalid_samples;
} 