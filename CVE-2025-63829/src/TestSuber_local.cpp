// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



#include "TestSuber.hpp"

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;

// Message array (for Fuzz testing, convenient for subsequent verification)
const char* fuzz_messages[] = {"FuzzMsg0", "FuzzMsg1", "FuzzMsg2", "FuzzMsg3", "FuzzMsg4", "FuzzMsg5", "FuzzMsg6", "FuzzMsg7", "FuzzMsg8", "FuzzMsg9", "FuzzMsg10", "FuzzMsg11", "FuzzMsg12", "FuzzMsg13", "FuzzMsg14", "FuzzMsg15", "FuzzMsg16", "FuzzMsg17", "FuzzMsg18", "FuzzMsg19"};
const size_t fuzz_message_count = sizeof(fuzz_messages)/sizeof(fuzz_messages[0]);

// Implementation of SubListener methods
void TestSuber::SubListener::on_subscription_matched(
    DataReader *,
    const SubscriptionMatchedStatus &info)
{
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    
    if (info.current_count_change == 1)
    {
        matched_ = info.total_count;
        std::cout << "[" << time_ms << "] Subscriber matched. (PID: " << getpt() << ")" << std::endl;
    }
    else if (info.current_count_change == -1)
    {
        matched_ = info.total_count;
        std::cout << "[" << time_ms << "] Subscriber unmatched. (PID: " << getpt() << ")" << std::endl;
    }
    else
    {
        std::cout << "[" << time_ms << "] " << info.current_count_change
                  << " is not a valid value for SubscriptionMatchedStatus current count change" << std::endl;
    }
}

void TestSuber::SubListener::on_data_available(
    DataReader *reader)
{
    SampleInfo info;
    if (reader->take_next_sample(&hello_, &info) == eprosima::fastdds::dds::RETCODE_OK)
    {
        if (info.valid_data)
        {
            samples_++;
            auto now = std::chrono::steady_clock::now();
            auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
            std::cout << "[" << time_ms << "] Message:  with index: " << hello_.index()
                      << " RECEIVED. (Total: " << samples_ << ")" << std::endl;
            std::cout << "[" << time_ms << "] Message:  with message: " << hello_.message()
                      << " RECEIVED. (Total: " << samples_ << ")" << std::endl;
            // // Check if ResourceLimits is effective
            // if (samples_ > 10) {
            //     std::cout << "[" << time_ms << "] WARNING: ResourceLimits exceeded! samples_ = " << samples_ << std::endl;
            // }
        }
    }
}

// Implementation of TestSuber methods
TestSuber::TestSuber()
    : participant_(nullptr), subscriber_(nullptr), topic_(nullptr), reader_(nullptr), type_(new HelloWorldPubSubType())
{
}

TestSuber::~TestSuber()
{
    if (reader_ != nullptr)
    {
        subscriber_->delete_datareader(reader_);
    }
    if (topic_ != nullptr)
    {
        participant_->delete_topic(topic_);
    }
    if (subscriber_ != nullptr)
    {
        participant_->delete_subscriber(subscriber_);
    }
    DomainParticipantFactory::get_instance()->delete_participant(participant_);
}

bool TestSuber::init()
{
    DomainParticipantQos participantQos;
    participantQos.name("Participant_subscriber");
    participant_ = DomainParticipantFactory::get_instance()->create_participant(0, participantQos);

    if (participant_ == nullptr)
    {
        return false;
    }

    // Register the Type
    type_.register_type(participant_);

    // Create the subscriptions Topic
    TopicQos tqos;
    qos_manager_.applyTopicQoS(tqos);

    topic_ = participant_->create_topic("HelloWorldTopic", "HelloWorld", tqos);

    if (topic_ == nullptr)
    {
        return false;
    }

    // Create the Subscriber
    SubscriberQos sqos;
    qos_manager_.applySubscriberQoS(sqos);
    subscriber_ = participant_->create_subscriber(sqos, nullptr);

    if (subscriber_ == nullptr)
    {
        return false;
    }

    // Create the DataReader
    DataReaderQos rqos;
    qos_manager_.applyDataReaderQoS(rqos);

    reader_ = subscriber_->create_datareader(topic_, rqos, &listener_);

    if (reader_ == nullptr)
    {
        return false;
    }

    return true;
}

void TestSuber::run(uint32_t samples)
{
    std::cout << "Waiting for Publisher connection..." << std::endl;
    
    // Wait for matching Publisher
    int wait_count = 0;
    const int max_wait = 3000; // Maximum wait 3000 times, 2ms each time
    while (listener_.matched_ == 0 && wait_count < max_wait)
    {
        std::cout << "Waiting for match... (" << wait_count + 1 << "/" << max_wait << ")" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(2)); // Changed to 2ms to improve response speed
        wait_count++;
    }
    // Print timestamp when exiting loop
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    std::cout << "Timestamp when exiting loop: " << time_ms << std::endl;
    // if (listener_.matched_ == 0)
    // {
    //     std::cout << "Warning: No matching Publisher found, but will continue waiting for messages..." << std::endl;
    // }
    // else
    // {
    //     std::cout << "Successfully matched to " << listener_.matched_ << " Publisher(s)" << std::endl;
    // }

    std::cout << "Start receiving messages, target: " << samples << " messages..." << std::endl;
    
    int check_count = 0;
    while (listener_.samples_ < samples)
    {
        check_count++;
        auto current_samples = listener_.samples_.load();
        auto now = std::chrono::steady_clock::now();
        auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
        std::cout << "[" << time_ms << "] Check #" << check_count << ": samples_ = " << current_samples << " (Target: " << samples << ")" << std::endl;
        
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    std::cout << "Received " << listener_.samples_ << " messages, program ended." << std::endl;
}

void TestSuber::configureQoS()
{
    // Get QoS manager and configure various QoS policies
    QoSManager& qos_manager = getQoSManager();
    
    std::cout << "\n=== Configure Subscriber QoS Policies ===" << std::endl;
    
    // 1. Reliability policy configuration (must match Publisher)
    std::cout << "1. Set reliability policy..." << std::endl;
    qos_manager.setReliability(RELIABLE_RELIABILITY_QOS);
    
    // 2. Topic history depth configuration
    std::cout << "2. Set Topic history depth..." << std::endl;
    qos_manager.setTopicHistoryDepth(20);
    
    // 3. Topic durability policy configuration
    std::cout << "3. Set Topic durability policy..." << std::endl;
    qos_manager.setTopicDurability(VOLATILE_DURABILITY_QOS);
    
    // 4. Partition configuration (must match Publisher)
    std::cout << "4. Set partition name..." << std::endl;
    qos_manager.setPartition("test_partition");
    
    // 5. User data configuration
    std::cout << "5. Set user data..." << std::endl;
    const uint8_t user_data[] = {1,2,3,4,5};
    qos_manager.setUserData(std::vector<uint8_t>(user_data, user_data + sizeof(user_data)/sizeof(user_data[0])));
    
    // 6. Time-related configuration
    std::cout << "6. Set time-related parameters..." << std::endl;
    
    // Deadline (set to infinite to avoid incompatibility if Publisher increases Deadline later)
    Duration_t deadline_period = c_TimeInfinite;
    qos_manager.setDeadline(deadline_period);
    
    // Lifespan (consistent with Publisher)
    Duration_t lifespan_duration;
    lifespan_duration.seconds = 1;
    lifespan_duration.nanosec = 1000000000;
    qos_manager.setLifespan(lifespan_duration);
    
    // Latency budget (consistent with Publisher)
    Duration_t latency_budget;
    latency_budget.seconds = 0;
    latency_budget.nanosec = 0;
    qos_manager.setLatencyBudget(latency_budget);
    
    // 7. Liveliness policy configuration (must match Publisher)
    std::cout << "7. Set liveliness policy..." << std::endl;
    qos_manager.setLiveliness(AUTOMATIC_LIVELINESS_QOS, createDuration(10, 0));
    
    // 8. Ownership policy configuration (must match Publisher)
    std::cout << "8. Set ownership policy..." << std::endl;
    qos_manager.setOwnership(SHARED_OWNERSHIP_QOS, 9999999999999999999999999999999999999999999);
    
    // 9. Time-based filter configuration (Subscriber only)
    std::cout << "9. Set time-based filter..." << std::endl;
    Duration_t time_filter;
    time_filter.seconds = 0;
    time_filter.nanosec = 100000;
    qos_manager.setTimeBasedFilter(time_filter);
    
    // 10. Disable positive acks configuration (must match Publisher)
    std::cout << "10. Set disable positive acks..." << std::endl;
    Duration_t disable_duration;
    disable_duration.seconds = 0;
    disable_duration.nanosec = 0;
    qos_manager.setDisablePositiveAcks(false, disable_duration);
    
    // 11. Resource limits policy configuration
    std::cout << "11. Set resource limits policy..." << std::endl;
    qos_manager.setResourceLimits(10, 5, 10);
    
    // 12. Resource allocation policy configuration
    std::cout << "12. Set resource allocation policy..." << std::endl;
    qos_manager.setResourceAllocation(20, 10, 20);
    
    // 13. Topic data configuration
    std::cout << "13. Set topic data..." << std::endl;
    const uint8_t topic_data[] = {5, 6, 7, 8, 9};
    qos_manager.setTopicData(std::vector<uint8_t>(topic_data, topic_data + sizeof(topic_data)/sizeof(topic_data[0])));
    
    // 14. Group data configuration
    std::cout << "14. Set group data..." << std::endl;
    const uint8_t group_data[] = {10, 11, 12, 13, 14};
    qos_manager.setGroupData(std::vector<uint8_t>(group_data, group_data + sizeof(group_data)/sizeof(group_data[0])));
    
    // 15. Presentation policy configuration
    std::cout << "15. Set presentation policy..." << std::endl;
    qos_manager.setPresentation(TOPIC_PRESENTATION_QOS, true, false);
    
    // 16. Destination order policy configuration
    std::cout << "16. Set destination order policy..." << std::endl;
    qos_manager.setDestinationOrder(BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS);
    
    // 17. Data representation configuration
    std::cout << "17. Set data representation..." << std::endl;
    qos_manager.setDataRepresentation(XCDR_DATA_REPRESENTATION);
    
    // 18. Type consistency enforcement configuration
    std::cout << "18. Set type consistency enforcement..." << std::endl;
    qos_manager.setTypeConsistencyEnforcement(DISALLOW_TYPE_COERCION);
    
    // 19. Reader data lifecycle configuration
    std::cout << "19. Set reader data lifecycle..." << std::endl;
    Duration_t reader_autopurge_nowriter_delay;
    reader_autopurge_nowriter_delay.seconds = 0;
    reader_autopurge_nowriter_delay.nanosec = 0;
    
    Duration_t reader_autopurge_disposed_delay;
    reader_autopurge_disposed_delay.seconds = 0;
    reader_autopurge_disposed_delay.nanosec = 0;
    
    qos_manager.setReaderDataLifecycle(reader_autopurge_nowriter_delay, reader_autopurge_disposed_delay, false);
    
    std::cout << "QoS configuration completed!" << std::endl;
}

// Helper function: Create Duration_t object
Duration_t createDuration(int32_t seconds, uint32_t nanoseconds)
{
    Duration_t duration;
    duration.seconds = seconds;
    duration.nanosec = nanoseconds;
    return duration;
}

int main(
    int argc,
    char **argv)
{
    std::cout << "Starting subscriber." << std::endl;
    uint32_t samples = 18446744073709551615;

    TestSuber *mysub = new TestSuber();
    
    // Configure QoS policies
    mysub->configureQoS();
    
    if (mysub->init())
    {
        mysub->run(samples);
    }

    delete mysub;
    return 0;
} 