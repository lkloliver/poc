
#include "TestPuber.hpp"

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;

const uint32_t PUBLISH_INTERVAL_MS = 10;

const char* fuzz_messages[] = {"FuzzMsg0", "FuzzMsg1", "FuzzMsg2", "FuzzMsg3", "FuzzMsg4", "FuzzMsg5", "FuzzMsg6", "FuzzMsg7", "FuzzMsg8", "FuzzMsg9", "FuzzMsg10", "FuzzMsg11", "FuzzMsg12", "FuzzMsg13", "FuzzMsg14", "FuzzMsg15", "FuzzMsg16", "FuzzMsg17", "FuzzMsg18", "FuzzMsg19"};
const size_t fuzz_message_count = sizeof(fuzz_messages)/sizeof(fuzz_messages[0]);

void TestPuber::PubListener::on_publication_matched(
        DataWriter*,
        const PublicationMatchedStatus& info)
{
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    if (info.current_count_change == 1)
    {
        matched_ = info.total_count;
    }
    else if (info.current_count_change == -1)
    {
        matched_ = info.total_count;
    }
}

TestPuber::TestPuber()
    : participant_(nullptr)
    , publisher_(nullptr)
    , topic_(nullptr)
    , writer_(nullptr)
    , type_(new HelloWorldPubSubType())
{
}

TestPuber::~TestPuber()
{
    if (writer_ != nullptr)
    {
        publisher_->delete_datawriter(writer_);
    }
    if (publisher_ != nullptr)
    {
        participant_->delete_publisher(publisher_);
    }
    if (topic_ != nullptr)
    {
        participant_->delete_topic(topic_);
    }
    DomainParticipantFactory::get_instance()->delete_participant(participant_);
}

bool TestPuber::init()
{
    
    DomainParticipantQos participantQos;
    participantQos.name("Participant_publisher");
    eprosima::fastdds::rtps::Locator_t locator;
    locator.kind = LOCATOR_KIND_UDPv4;
    eprosima::fastdds::rtps::IPLocator::setPhysicalPort(locator, 7415); // Set physical port (UDP port)
    participantQos.wire_protocol().default_unicast_locator_list.push_back(locator);
    
    participant_ = DomainParticipantFactory::get_instance()->create_participant(0, participantQos);

    if (participant_ == nullptr)
    {
        return false;
    }

    type_.register_type(participant_);

    TopicQos tqos;
    try {
        qos_manager_.applyTopicQoS(tqos);
    } catch (const std::exception& e) {
        return false;
    }

    topic_ = participant_->create_topic("HelloWorldTopic", "HelloWorld", tqos);

    if (topic_ == nullptr)
    {
        return false;
    }

    PublisherQos pqos;
    try {
        qos_manager_.applyPublisherQoS(pqos);
    } catch (const std::exception& e) {
        return false;
    }
    publisher_ = participant_->create_publisher(pqos, nullptr);

    if (publisher_ == nullptr)
    {
        return false;
    }

    DataWriterQos wqos;
    try {
        qos_manager_.applyDataWriterQoS(wqos);
    } catch (const std::exception& e) {
        return false;
    }

    auto start_time = std::chrono::steady_clock::now();
    
    writer_ = publisher_->create_datawriter(topic_, wqos, &listener_);
    
    auto end_time = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time);

    if (writer_ == nullptr)
    {
        return false;
    }
    return true;
}

bool TestPuber::publish()
{
    if (listener_.matched_ > 0)
    {
        hello_.index(hello_.index() + 1);
        writer_->write(&hello_);
        return true;
    }
    return false;
}

void TestPuber::run(uint32_t samples)
{
    
    int wait_count = 0;
    const int max_wait = 3000;
    while (listener_.matched_ == 0 && wait_count < max_wait)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(2));
        wait_count++;
    }
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    if (listener_.matched_ == 0)
    {
    }

    for (size_t i = 0; i < 18446744073709551615; ++i) {
        std::stringstream ss;
        // Fixed message size to avoid blocking or fragmentation overhead from oversized messages
        ss << std::string(1024, '1');
        hello_.message(ss.str());
        hello_.index(i);

        // Example 4: Dynamically adjust deadline based on time interval (simulate network condition changes)
        // Check and possibly adjust deadline every 1000 messages
        if (i > 0 && i % 1000 == 0)
        {
            // Simulation: If message publish frequency is high, deadline can be appropriately extended
            // This is only an example, in actual applications it should be decided based on real network conditions or performance metrics
            if (i % 2000 == 0)
            {
                std::cout << "\n=== Modify lifespan nanoseconds to 1000000000 ===" << std::endl;
                // Change QoS: Only adjust lifespan to avoid incompatibility with Reader's Deadline
                if (updateQoSDynamically(1, -1, -1))
                {
                    // Give DDS some time for reconfiguration
                    std::this_thread::sleep_for(std::chrono::milliseconds(200));
                    // Send a probe message to verify if the path is normal after QoS change
                    hello_.message(std::string("probe_after_qos_change"));
                    hello_.index(i);
                    writer_->write(&hello_);
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        }

        
        if (!writer_->write(&hello_)) {
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(PUBLISH_INTERVAL_MS));
    }

}

void TestPuber::configureQoS()
{
    QoSManager& qos_manager = getQoSManager();
    
    
    qos_manager.setReliability(RELIABLE_RELIABILITY_QOS);
    
    qos_manager.setTopicHistoryDepth(20);
    
    qos_manager.setTopicDurability(VOLATILE_DURABILITY_QOS);
    
    qos_manager.setPartition("test_partition");
    
    const uint8_t user_data[] = {1,2,3,4,5};
    qos_manager.setUserData(std::vector<uint8_t>(user_data, user_data + sizeof(user_data)/sizeof(user_data[0])));
    
    
    Duration_t deadline_period;
    deadline_period.seconds = 1;
    deadline_period.nanosec = 0;
    qos_manager.setDeadline(deadline_period);
    
    Duration_t lifespan_duration;
    lifespan_duration.seconds = 1;
    lifespan_duration.nanosec = 0;
    qos_manager.setLifespan(lifespan_duration);
    
    Duration_t latency_budget;
    latency_budget.seconds = 0;
    latency_budget.nanosec = 0;
    qos_manager.setLatencyBudget(latency_budget);
    
    qos_manager.setLiveliness(AUTOMATIC_LIVELINESS_QOS, createDuration(10, 0));
    
    qos_manager.setOwnership(SHARED_OWNERSHIP_QOS, 999999);
    
    qos_manager.setPublishMode(SYNCHRONOUS_PUBLISH_MODE);
    
    Duration_t disable_duration;
    disable_duration.seconds = 0;
    disable_duration.nanosec = 0;
    qos_manager.setDisablePositiveAcks(false, disable_duration);
    
    qos_manager.setResourceLimits(10, 5, 10);
    
    qos_manager.setResourceAllocation(20, 10, 20);
    
    const uint8_t topic_data[] = {5, 6, 7, 8, 9};
    qos_manager.setTopicData(std::vector<uint8_t>(topic_data, topic_data + sizeof(topic_data)/sizeof(topic_data[0])));
    
    const uint8_t group_data[] = {10, 11, 12, 13, 14};
    qos_manager.setGroupData(std::vector<uint8_t>(group_data, group_data + sizeof(group_data)/sizeof(group_data[0])));
    
    qos_manager.setPresentation(TOPIC_PRESENTATION_QOS, true, false);
    
    qos_manager.setDestinationOrder(BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS);
    
    qos_manager.setTransportPriority(5);
    
    qos_manager.setDurabilityService(KEEP_LAST_HISTORY_QOS, 1, 
                                   200, 40, 
                                   50);
    
    qos_manager.setDataRepresentation(XCDR_DATA_REPRESENTATION);
    
    qos_manager.setTypeConsistencyEnforcement(DISALLOW_TYPE_COERCION);
    
    Duration_t writer_autopurge_delay;
    writer_autopurge_delay.seconds = 0;
    writer_autopurge_delay.nanosec = 0;
    qos_manager.setWriterDataLifecycle(true, writer_autopurge_delay);
    
}

bool TestPuber::updateQoSDynamically(int32_t new_lifespan_sec, 
                                      int32_t new_deadline_sec,
                                      int32_t new_transport_priority)
{
    if (writer_ == nullptr)
    {
        std::cout << "Error: DataWriter not initialized, cannot modify QoS" << std::endl;
        return false;
    }

    std::cout << "\n=== Publisher dynamically modifies DataWriter QoS ===" << std::endl;

    // 1. Get current QoS configuration
    DataWriterQos current_qos;
    ReturnCode_t ret = writer_->get_qos(current_qos);
    if (ret != RETCODE_OK)
    {
        std::cout << "Error: Cannot get current QoS configuration, return code: " << ret << std::endl;
        return false;
    }

    bool modified = false;

    // 2. Modify lifespan (Lifespan)
    if (new_lifespan_sec >= 0)
    {
        std::cout << "[Publisher] Modify lifespan: " 
                  << current_qos.lifespan().duration.nanosec << " nanoseconds -> " 
                  << 1000000000 << " nanoseconds" << std::endl;
        //current_qos.lifespan().duration.seconds = new_lifespan_sec;
        current_qos.lifespan().duration.nanosec = 1000000000;
        //current_qos.lifespan().duration.nanosec = 0;
        modified = true;
    }

    // 3. Modify deadline (Deadline)
    if (new_deadline_sec >= 0)
    {
        std::cout << "[Publisher] Modify deadline: " 
                  << current_qos.deadline().period.seconds << " seconds -> " 
                  << new_deadline_sec << " seconds" << std::endl;
        current_qos.deadline().period.seconds = new_deadline_sec;
        //current_qos.deadline().period.nanosec = 1000000000;
        current_qos.deadline().period.nanosec = 0;
        modified = true;
    }

    // 4. Modify transport priority (TransportPriority)
    if (new_transport_priority >= 0)
    {
        std::cout << "[Publisher] Modify transport priority: " 
                  << current_qos.transport_priority().value << " -> " 
                  << new_transport_priority << std::endl;
        current_qos.transport_priority().value = new_transport_priority;
        modified = true;
    }

    // 5. If there is nothing to modify, return directly
    if (!modified)
    {
        std::cout << "[Publisher] No QoS policies need to be modified" << std::endl;
        return true;
    }

    // 6. Apply modified QoS
    std::cout << "[Publisher] Applying modified QoS..." << std::endl;
    ret = writer_->set_qos(current_qos);

    // 7. Check result
    if (ret == RETCODE_OK)
    {
        std::cout << "[Publisher] ✓ QoS updated successfully!" << std::endl;
        std::cout << "[Publisher]   Note: QoS changes have been propagated to connected Subscribers via DDS mechanism" << std::endl;
        
        // Verify if modification was successful
        DataWriterQos verify_qos;
        writer_->get_qos(verify_qos);
        
        if (new_lifespan_sec >= 0)
        {
            std::cout << "[Publisher]   Verify lifespan: " 
                      << verify_qos.lifespan().duration.seconds << " seconds" << std::endl;
        }
        if (new_deadline_sec >= 0)
        {
            std::cout << "[Publisher]   Verify deadline: " 
                      << verify_qos.deadline().period.seconds << " seconds" << std::endl;
        }
        if (new_transport_priority >= 0)
        {
            std::cout << "[Publisher]   Verify transport priority: " 
                      << verify_qos.transport_priority().value << std::endl;
        }
        
        return true;
    }
    else if (ret == RETCODE_IMMUTABLE_POLICY)
    {
        std::cout << "[Publisher] ✗ Error: Attempted to modify immutable QoS policy" << std::endl;
        std::cout << "[Publisher]   Note: Some QoS policies (such as reliability, durability, liveliness, etc.) cannot be modified once enabled" << std::endl;
        return false;
    }
    else if (ret == RETCODE_INCONSISTENT_POLICY)
    {
        std::cout << "[Publisher] ✗ Error: QoS configuration inconsistent" << std::endl;
        return false;
    }
    else
    {
        std::cout << "[Publisher] ✗ Error: Failed to modify QoS, return code: " << ret << std::endl;
        return false;
    }
}

Duration_t createDuration(int32_t seconds, uint32_t nanoseconds)
{
    Duration_t duration;
    duration.seconds = seconds;
    duration.nanosec = nanoseconds;
    return duration;
}

int main(
        int argc,
        char** argv)
{
    uint32_t samples = 20;

    TestPuber* mypub = new TestPuber();
    
    mypub->configureQoS();
    
    if(mypub->init())
    {
        mypub->run(samples);
    }

    delete mypub;
    return 0;
} 