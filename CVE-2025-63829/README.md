## 一 download Fast-DDS

```shell
mkdir Fast
cd Fast
#安装Fast-CDR
git clone https://github.com/eProsima/Fast-CDR.git

mkdir Fast-CDR/build

cd Fast-CDR/build

cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/

cmake --build . --target install

cd ../..
#安装Fast-DDS
git clone https://github.com/eProsima/Fast-DDS.git

mkdir Fast-DDS/build

cd Fast-DDS/build

cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/ -DBUILD_SHARED_LIBS=ON

sudo cmake --build . --target install
```

## 二 run

1.local
```shell
./build/TestSuber_local
```
2.remote
```shell
./build/TestSuber
```
```shell
./build/TestPuber
```
## 三 detail

### 1.source code address

```cpp
//./Fast-DDS/src/cpp/fastdds/core/Time_t.cpp
uint32_t Time_t::fraction() const
{
    uint32_t fraction = (nanosec == 0xffffffff)
        ? 0xffffffff
        : nano_to_frac(nanosec);
    
    if (fraction != 0xffffffff)
    {
        uint32_t nano_check = frac_to_nano(fraction);
        
        int loop_count = 0;
        while (nano_check != nanosec)
        {
            loop_count++;
            nano_check = frac_to_nano(++fraction);
        }
    }

    return fraction;
}
```


### 2.reason

When the value of the parameter nanosec in the QoS policy is set to 1000000000, the following situation will occur:
1.The `nano_to_frac(nanosec)` function converts 1000000000 to its corresponding fraction value
2. Since fraction is of type uint32_t, its maximum value is 4294967295 (0xffffffff)
3. When the value of `fraction` reaches 4294967295, executing `++fraction` will result in integer overflow, causing `fraction` to become 0
4. The value returned by `frac_to_nano(0)` will never be equal to 1000000000
5. Therefore, the while loop condition `nano_check != nanosec` will always be true, resulting in an infinite loop

### 3.condition
The triggering of this vulnerability requires the following conditions to be met:

1. Customize the QoS (Quality of Service) policy of FastDDS in the application
2. Set time-related parameters in the QoS policy so that the nanosec field is set to 1000000000
3. System calls the Time_t::fraction() function

Currently, two types of exploiting vulnerabilities have been discovered:

1. The QOS policy initially configured for the application is incorrect, leading to an infinite loop during the startup phase.
2. The QOS configured initially for the application is normal, and the subscriber and publisher are matched and establish communication normally. However, the publisher can modify the QOS policy during the communication process, causing the currently established communication thread to enter an infinite loop and unable to receive subsequent messages