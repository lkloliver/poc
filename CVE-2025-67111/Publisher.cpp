/*
 * Distributed under the OpenDDS License.
 * See: http://www.opendds.org/license.html
 */

#include "Boilerplate.h"
#include <dds/DCPS/Service_Participant.h>
#include <dds/DCPS/WaitSet.h>
#include <dds/DdsDcpsInfrastructureC.h>
#include <dds/DdsDcpsPublicationC.h>
#include <stdexcept>
#include <iostream>

#include "dds/DCPS/StaticIncludes.h"

using namespace examples::rtps_poc;

int
ACE_TMAIN(int argc, ACE_TCHAR *argv[])
{
  try {
    // Initialize DomainParticipantFactory, handling command line args
    DDS::DomainParticipantFactory_var dpf =
      TheParticipantFactoryWithArgs(argc, argv);

    // Create domain participant
    DDS::DomainParticipant_var participant = createParticipant(dpf);

    // Register type support and create topic
    DDS::Topic_var topic = createTopic(participant);

    // Create publisher
    DDS::Publisher_var publisher = createPublisher(participant);

    // Create data writer for the topic
    DDS::DataWriter_var writer = createDataWriter(publisher, topic);

    // Safely downcast data writer to type-specific data writer
    Message::HelloWorldDataWriter_var msg_writer = narrow(writer.in());

    // Block until Subscriber is available (same as Messenger example)
    DDS::StatusCondition_var condition = writer->get_statuscondition();
    condition->set_enabled_statuses(DDS::PUBLICATION_MATCHED_STATUS);

    DDS::WaitSet_var ws = new DDS::WaitSet;
    ws->attach_condition(condition);

    std::cout << "Publisher: Waiting for Subscriber..." << std::endl;

    while (true) {
      DDS::PublicationMatchedStatus matches;
      if (writer->get_publication_matched_status(matches) != DDS::RETCODE_OK) {
        ACE_ERROR_RETURN((LM_ERROR,
                          ACE_TEXT("ERROR: %N:%l: main() -")
                          ACE_TEXT(" get_publication_matched_status failed!\n")),
                         -1);
      }

      if (matches.current_count >= 1) {
        break;
      }

      DDS::ConditionSeq conditions;
      DDS::Duration_t timeout = { 60, 0 };
      if (ws->wait(conditions, timeout) != DDS::RETCODE_OK) {
        ACE_ERROR_RETURN((LM_ERROR,
                          ACE_TEXT("ERROR: %N:%l: main() -")
                          ACE_TEXT(" wait failed!\n")),
                         -1);
      }
    }

    std::cout << "Publisher: Subscriber is available" << std::endl;
    ws->detach_condition(condition);

    // Initialize samples
    Message::HelloWorld msg;
    msg.id = 1;
    msg.message = "Hello from Publisher";
    msg.count = 0;

    // Override message count
    int msg_count = 1000;
    if (argc > 1) {
      msg_count = ACE_OS::atoi(argv[1]);
    }

    std::cout << "Publisher: Starting to send " << msg_count << " messages..." << std::endl;

    for (int i = 0; i < msg_count; ++i) {
      // Publish the message
      DDS::ReturnCode_t error = msg_writer->write(msg, DDS::HANDLE_NIL);
      if (error != DDS::RETCODE_OK) {
        ACE_ERROR((LM_ERROR,
                   ACE_TEXT("ERROR: %N:%l: main() -")
                   ACE_TEXT(" write returned %d!\n"), error));
      } else {
        std::cout << "Publisher: Sent message " << (i + 1) 
                  << " (id=" << msg.id << ", count=" << msg.count << ")" << std::endl;
      }

      // Prepare next sample
      ++msg.count;
      ++msg.id;
      sleep(1);
    }

    // Wait for samples to be acknowledged (same as Messenger example)
    DDS::Duration_t timeout = { 30, 0 };
    if (msg_writer->wait_for_acknowledgments(timeout) != DDS::RETCODE_OK) {
      ACE_ERROR((LM_ERROR,
                        ACE_TEXT("ERROR: %N:%l: main() -")
                 ACE_TEXT(" wait_for_acknowledgments failed!\n")));
    }

    // Clean-up!
    cleanup(participant, dpf);

  } catch (const CORBA::Exception& e) {
    e._tao_print_exception("Exception caught in main():");
    return -1;
  } catch (std::runtime_error& err) {
    ACE_ERROR_RETURN((LM_ERROR, ACE_TEXT("ERROR: main() - %C\n"),
                      err.what()), -1);
  } catch (std::string& msg) {
    ACE_ERROR_RETURN((LM_ERROR, ACE_TEXT("ERROR: main() - %C\n"),
                      msg.c_str()), -1);
  }

  return 0;
}
