/*
 * Distributed under the OpenDDS License.
 * See: http://www.opendds.org/license.html
 */

#include "DataReaderListenerImpl.h"
#include "Boilerplate.h"
#include <iostream>

DataReaderListenerImpl::DataReaderListenerImpl()
  : sample_count_(0)
{
}

DataReaderListenerImpl::~DataReaderListenerImpl()
{
  std::cerr << "[DataReaderListenerImpl::~DataReaderListenerImpl] this=" << this << std::endl << std::flush;
}

void DataReaderListenerImpl::on_requested_deadline_missed(
  DDS::DataReader_ptr,
  const DDS::RequestedDeadlineMissedStatus&)
{
}

void DataReaderListenerImpl::on_requested_incompatible_qos(
  DDS::DataReader_ptr,
  const DDS::RequestedIncompatibleQosStatus&)
{
}

void DataReaderListenerImpl::on_sample_rejected(
  DDS::DataReader_ptr,
  const DDS::SampleRejectedStatus&)
{
}

void DataReaderListenerImpl::on_liveliness_changed(
  DDS::DataReader_ptr,
  const DDS::LivelinessChangedStatus&)
{
}

void DataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader)
{
  std::cerr << "[DataReaderListenerImpl::on_data_available] entry, reader=" << reader << std::endl << std::flush;
  Message::HelloWorldDataReader_var message_dr =
    examples::rtps_poc::narrow(reader);

  if (!message_dr) {
    std::cerr << "[DataReaderListenerImpl::on_data_available] narrow failed" << std::endl << std::flush;
    return;
  }

  // Process only one sample per callback (same as Messenger example)
  // OpenDDS will trigger on_data_available() again when new samples arrive
  Message::HelloWorld msg;
  DDS::SampleInfo si;

  std::cerr << "[DataReaderListenerImpl::on_data_available] before take_next_sample" << std::endl << std::flush;
  const DDS::ReturnCode_t status = message_dr->take_next_sample(msg, si);
  std::cerr << "[DataReaderListenerImpl::on_data_available] after take_next_sample, status=" << status << std::endl << std::flush;

  if (status == DDS::RETCODE_OK && si.valid_data) {
    ++sample_count_;
    std::cout << "Subscriber: Received message " << sample_count_
              << " (id=" << msg.id << ", count=" << msg.count
              << ", message=\"" << msg.message.in() << "\")" << std::endl;
    std::cerr << "[DataReaderListenerImpl::on_data_available] processed sample " << sample_count_ << std::endl << std::flush;
  } else if (status != DDS::RETCODE_NO_DATA) {
    std::cerr << "[DataReaderListenerImpl::on_data_available] take_next_sample returned " << status << std::endl << std::flush;
  }
  std::cerr << "[DataReaderListenerImpl::on_data_available] exit" << std::endl << std::flush;
}

void DataReaderListenerImpl::on_subscription_matched(
  DDS::DataReader_ptr,
  const DDS::SubscriptionMatchedStatus& status)
{
  if (status.current_count_change > 0) {
    std::cout << "Subscriber: Matched with a DataWriter" << std::endl;
  } else {
    std::cout << "Subscriber: Unmatched from a DataWriter" << std::endl;
  }
}

void DataReaderListenerImpl::on_sample_lost(
  DDS::DataReader_ptr,
  const DDS::SampleLostStatus&)
{
}

