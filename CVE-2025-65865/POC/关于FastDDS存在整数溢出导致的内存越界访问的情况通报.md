# 关于FastDDS存在整数溢出导致的内存越界访问的情况通报
## 一、漏洞描述

Fast-DDS（`Fast Data Distribution Service`）是一种高性能、可扩展的数据分发服务，它实现了 `OMG DDS`（`Object Management Group Data Distribution Service`）标准。它是一个开源项目，旨在提供实时数据通信和消息传递的解决方案。`FastDDS`截止到目前最新的3.3版本均存在由于整数溢出导致的内存越界访问漏洞，攻击者可利用该漏洞造成程序崩溃。

## 二、漏洞类型

CWE-190: Integer Overflow or Wraparound

CWE-125: Out-of-bounds Read

## 三、漏洞复现

在`Ubuntu 24.04 LTS`（`docker`）测试`FastDDS 3.2`、`FastDDS 3.3`及最新`master`分支
（2025/9/2）均可复现该漏洞，以下以`Ubuntu 24.04 LTS`和最新`master`分支（已在附件内单独提供
`FastDDS-master.zip`）为例，后续将漏洞反馈给官方后可能在`master`分支上进行修复。

### 1.下载并编译`Fast-DDS`

```shell
mkdir Fast
cd Fast
#安装Fast-CDR
git clone https://github.com/eProsima/Fast-CDR.git

mkdir Fast-CDR/build

cd Fast-CDR/build

cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/

cmake --build . --target install

cd ../..
#安装Fast-DDS
git clone https://github.com/eProsima/Fast-DDS.git

mkdir Fast-DDS/build

cd Fast-DDS/build

cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/ -DBUILD_SHARED_LIBS=ON

sudo cmake --build . --target install
```



### 2.运行POC脚本文件（由于使用文件较多，作为附件单独放置）

#### 前置条件
- 确保系统已安装`cmake`、`gcc/g++`编译环境
- 确保`FastDDS`已正确安装到系统路径
- 确保网络环境允许`DDS`通信（默认端口7400-7500）
- 被攻击者使用默认的`udp`通信

#### 复现步骤

**步骤1: 启动正常的`DDS`订阅者/发布者**
```shell
cd ./DDSTest/build
make
./TestSuber > Sub.out
```
```shell
cd ./DDSTest/build
./TestPuber > Pub.out
```

**步骤2: 运行攻击程序**
```shell
cd ./POC/build
make
./TestPuberCore
```
现象如下

![屏幕截图 2025-10-08 105747](C:\Users\hrbjt\Pictures\Screenshots\屏幕截图 2025-10-08 105747.png)



## 四、漏洞详解

### 1.漏洞代码具体位置

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
bool MessageReceiver::proc_Submsg_DataFrag(
......
//1028行
payload_size = smh->submessageLength - (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);
......
```

整数溢出位置在1028行。

`RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE`是一个常量定义为4，代表`inlineQos`结束标识的长度。

`smh->submessageLength`取值来源于报文中的字段`octstsToHeader`

`octetsToInlineQos`来源于报文中的同名字段值

`inlineQosSize`来源于报文中的同名字段值。

### 2.漏洞形成直接原因
`smh->submessageLength`仅在`proc_Submsg_DataFrag`函数入口处920行判断不小于`RTPSMESSAGE_DATA_MIN_LENGTH`（常量24，报文除去`header`外的最小长度）。

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
bool MessageReceiver::proc_Submsg_DataFrag(
......
//920行
if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)
{
    ......
    return false;
}
......
```

`octetsToInlineQos`仅在1000行有比较判断，且实际上其实际的值一般不会大于`RTPSMESSAGE_OCTETSTOINLINEQOS_DATAFRAGSUBMSG`（常量28，表示`data_frag`类型的报文中`inlineQos`字段与`octetsToInlineQos`字段中间的字段总长）。

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
bool MessageReceiver::proc_Submsg_DataFrag(
......
//1000行
if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATAFRAGSUBMSG)
{
    msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATAFRAGSUBMSG);
    if (msg->pos > msg->length)
    {
        .....
        return false;
    }
}
......
```

`inlineQosSize`由于`inlineQos`结束标识的存在有着严格的长度控制。

这就存在一种情况：如果输入的报文中`octstsToHeader`的值在比24大的基础上小于4+`octetsToInlineQos`的值+`inlineQos`的值，就可以让`payload_size`实现整数下溢。

同时因为此时`msg->pos`由于已经读取完`inlineQos`的内容，指针位于`inlineQos`后面，所以其值为4+`octetsToInlineQos`的值+`inlineQos`的值+子消息`header`的长度（1（`submessage ID`）+1（`Flags`）+2（`octstsToHeader`）+2（`Extra flags`）=6）

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
bool MessageReceiver::proc_Submsg_DataFrag(
......
//1015行
if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))
......
```

此时的`next_pos`的值就会再次整数上溢反而恢复到一个正常的数字范围，其值为`smh->submessageLength`+6。而在下面的`if`判断中`msg->length`的值不是读取字段是直接从缓冲区的长度的获取的，所以只要实际的`Data_frag`子消息的长度大于`octstsToHeader`字段的值+6即可通过`if`检查。

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
bool MessageReceiver::proc_Submsg_DataFrag(
......
//1030行
uint32_t next_pos = msg->pos + payload_size;
if (msg->length >= next_pos && payload_size > 0)
{
    ch.serializedPayload.data = &msg->buffer[msg->pos];
    ch.serializedPayload.length = payload_size;
    ch.serializedPayload.max_size = payload_size;
    ch.serializedPayload.is_serialized_key = keyFlag;
    ch.setFragmentSize(fragmentSize);

    msg->pos = next_pos;
}
......
```

表达式`&msg->buffer[msg->pos]`用于获取报文中的`payload`字段，此时`msg->pos`指针位于`inlineQos`结束标识之后。当`payload`不存在时，攻击者可以通过构造整数下溢，绕过条件检查进入该`if`分支，这将导致`&msg->buffer[msg->pos]`访问到合法子消息边界之外的内存区域。此时，`length`字段会被设置为一个接近`uint32_t`上限的超大值，而`fragmentSize`字段则会在未经任何有效性检查的情况下被保存。

```cpp
// ./Fast-DDS/include/fastdds/rtps/common/CacheChange.hpp
bool add_fragments(
......
//288行
uint32_t incoming_length = fragment_size_ * fragments_in_submessage;
......
//323行
memcpy(
        &serializedPayload.data[original_offset],
        incoming_data.data, incoming_length);
......
```

`add_fragments`函数在处理每个报文时被调用一次，其中`fragments_in_submessage`表示当前报文携带的`data_frag`子消息数量，`fragment_size_`表示每个片段的声明长度。然而，`fragment_size_`的值并非来自实际的片段数据长度，而是直接从报文中占2字节的`fragmentSize`字段读取，该值可由攻击者任意指定。以本`POC`构造的`RTPS`数据包为例，通过设置0x330个`frag`子消息，计算得到的`incoming_length`值达到了0x32ffcd0（约53MB）。由于`memcpy`按地址递增顺序执行拷贝操作，当拷贝如此巨大的非法长度时，极有可能访问到进程合法地址空间之外的无效内存区域，从而触发段错误（`segmentation fault`）。

需要注意的是，`original_offset`可以被拷贝长度的理论上限受报文中`samplesize`字段（占4字节，表示总消息长度）的约束，最大值为0xffffffff（约4GB）。因此，在最坏的攻击场景下，`memcpy`可能访问从合法子消息起始位置延伸最长达0xffffffff字节范围内的任意内存区域，造成严重的越界读取漏洞。

### 3.漏洞形成的间接原因

#### 1
由于`msg->length`是实际的缓冲区长度，所以当`octstsToHeader`的值小于实际的子消息长度时由于未读取完成会继续418行的循环。但根据592行的赋值，`msg->pos`却又并非处于处理了一个子消息后实际的读取后位置，而是根据`octstsToHeader`的值移动到下一个子消息的首字节。

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
void MessageReceiver::processCDRMsg(
...... 
//418行
while (msg->pos < msg->length)
......
//446行
    uint32_t next_msg_pos = submessage->pos;
    next_msg_pos += (submsgh.submessageLength + 3u) & ~3u;
......
//592行
	submessage->pos = next_msg_pos;
......
```

且`inlineQos`的内容如果其参数`ID`不在`case`的列表里就会未检查内容直接通过

```cpp
//./Fast-DDS/src/cpp/fastdds/core/policy/ParameterList.cpp
bool ParameterList::updateCacheChangeFromInlineQos(
......
//157行
	default:
        break;
}

return true;
......
```

那么就可以将`inlineQos`的实际内容替换为一个不影响其它内容但是结构合法的子消息，例如`Info_TS`子消息（仅提供当前时间戳）。然后只需精准构造`octstsToHeader`的值使得`msg->pos`计算后的值恰好落在这个构造后的`inlineQos`的首字节，即可骗过检查正常通过。

在`inlineQos`尾部有一个必须添加的4字节的结束标识，其内容为0x01，0x00，0x00，0x00。而0x01恰好在循环进行的子消息识别中有一个对应的`case`，为`PAD`，但该`case`暂时没用被实现，所以会直接通过。0x00的情况也会直接通过该字节。

```cpp
//./Fast-DDS/src/cpp/rtps/messages/MessageReceiver.cpp
void MessageReceiver::processCDRMsg(
......
//559行
case PAD:
    break;
......
//583行
default:
    break;
......
```

#### 2
`fastdds`对于`qos`的分区仅在发现阶段使用，此时的`accept_messages_from_unkown_writers_`为`true`。当匹配了一个发布者之后`accept_messages_from_unkown_writers_`就会被设置为`false`，但同样`qos`策略也不再使用。由代码可知在正常通信过程中订阅者仅通过数据包里`writer`的`entityId`和`guid`来判断是否接收该消息。因此只要从一个正常通信的订阅者/发布者对中捕捉到`writer`的`guid`和`entityId`，就可以构造一个绕过`qos`策略直接被订阅者收到的数据包。但如果是共享内存的模式由于无法监听则无法使用。
```cpp
//./Fast-DDS/src/cpp/rtps/reader/StatelessReader.cpp
//889 行
bool StatelessReader::acceptMsgFrom(
        const GUID_t& writerId,
        ChangeKind_t change_kind)
{
    if (change_kind == ChangeKind_t::ALIVE)
    {
        if (accept_messages_from_unkown_writers_)
        {
            return true;
        }
        else if (writerId.entityId == trusted_writer_entity_id_)
        {
            return true;
        }
    }

    return std::any_of(matched_writers_.begin(), matched_writers_.end(),
                   [&writerId](const RemoteWriterInfo_t& writer)
                   {
                       return writer.guid == writerId;
                   });
}
```
## 五、漏洞利用
### 利用条件
网络可达性：攻击者需要能够向目标FastDDS实例发送恶意构造的RTPS数据包
端口访问：需要访问DDS通信的默认端口范围（7400-7500）
信息收集：需要获取目标系统中正常通信的writer的GUID和entityId信息，因此目标系统需要使用UDP通信
### 应用场景
**ROS 2**：所有使用FastDDS作为默认中间件的ROS 2版本
在ROS（Robot Operating System）等基于FastDDS的系统中：
- **机器人系统瘫痪**：攻击关键机器人节点的DDS通信，导致控制系统失效
- **多机器人协作中断**：机器人间的协调通信被破坏
- **自动驾驶干扰**：在车联网场景中，干扰自动驾驶车辆的感知数据通信

**工业物联网**：使用FastDDS进行设备间通信的IIoT平台：
- **工业控制系统中断**：影响基于DDS的工业实时通信系统
- **生产安全**：可能造成生产线紧急停机
- **数据完整性**：生产过程数据丢失
### 危害性
攻击者只要可以监听到其他人的writer信息就可以轻易造成其他人的订阅端崩溃，危害性较高。

## 六、解决方案
### 1.临时解决方案

- 添加`octstsToHeader`检查确保其不会小于`RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE` + `octetsToInlineQos` + `inlineQosSize`
- 读取子消息的`while`循环应当保持`pos`指针与读取字节的位置同步，而非根据输入的`octstsToHeader`字段进行移动。
- 对于`inlineQOS`参数，不在头文件定义中的`ID`值应当返回`False`
- 对`incoming_length`作检查不能大于`octstsToHeader`

### 2.正式解决方案
暂无，后续将与开发者反馈协商完成正式补丁