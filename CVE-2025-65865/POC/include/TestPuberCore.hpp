// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file TestPuberCore.hpp
 * @brief FastDDS发布者测试类头文件
 * 
 * 本文件定义了TestPuber类，用于测试FastDDS发布者功能，
 * 包含QoS配置管理和消息发布功能。
 * 
 * 此文件由Python脚本自动生成，请勿手动修改。
 */

 #ifndef TESTPUBER_HPP
 #define TESTPUBER_HPP
 
 #include "HelloWorldPubSubTypes.hpp"
 #include "QoSManager.hpp"
 
 #include <chrono>
 #include <thread>
 #include <atomic>
 #include <iostream>
 #include <vector>
 #include <map>
#include <mutex>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <set>
#include <optional>
 
 #include <fastdds/dds/domain/DomainParticipant.hpp>
 #include <fastdds/dds/domain/DomainParticipantFactory.hpp>
 #include <fastdds/dds/publisher/DataWriter.hpp>
 #include <fastdds/dds/publisher/DataWriterListener.hpp>
 #include <fastdds/dds/publisher/Publisher.hpp>
 #include <fastdds/dds/publisher/qos/DataWriterQos.hpp>
 #include <fastdds/dds/topic/TypeSupport.hpp>
 #include <fastdds/rtps/common/Time_t.hpp>
 #include <fastdds/dds/topic/qos/TopicQos.hpp>
 #include <fastdds/dds/publisher/qos/PublisherQos.hpp>
#include <fastdds/dds/subscriber/qos/DataReaderQos.hpp>

// UDP监听相关头文件
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <poll.h>

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;
 
 // ==================== 模糊测试相关结构体定义 ====================
 
 // 字段类型枚举
 enum class FieldType {
     MAGIC_HEADER,
     PROTOCOL_VERSION,
     VENDOR_ID,
     GUID_PREFIX,
     SUBMESSAGE_ID,
     FLAGS,
     OCTETS_TO_NEXT,
     ENTITY_ID,
     SEQUENCE_NUMBER,
     TIMESTAMP,
     CDR_DATA,
     PADDING
 };
 
 // 字段修改结构体
 struct FieldModification {
     FieldType field_type;
     size_t offset;
     size_t length;
     std::vector<uint8_t> original_data;
     std::vector<uint8_t> modified_data;
     std::string description;
 };
 
 // 异常检测结果枚举
 enum class AnomalyType {
     EXPECTED_RECEIVE_ACTUAL_DROP,    // 期望接收但实际丢弃
     EXPECTED_DROP_ACTUAL_RECEIVE,    // 期望丢弃但实际接收
     NORMAL_BEHAVIOR                  // 正常行为
 };
 
 // 期望接收记录结构体
 struct ExpectedReceptionRecord {
     int sequence_number;
     bool should_receive;
     std::string fuzz_description;
     std::string field_description;
     std::chrono::system_clock::time_point timestamp;
 };
 
 // 模糊测试配置结构体
 struct FuzzConfig {
     bool enable_magic_header_fuzz = true;
     bool enable_protocol_version_fuzz = true;
     bool enable_vendor_id_fuzz = true;
     bool enable_guid_prefix_fuzz = true;
     bool enable_submessage_fuzz = true;
     bool enable_flags_fuzz = true;
     bool enable_entity_id_fuzz = true;
     bool enable_sequence_number_fuzz = true;
     bool enable_timestamp_fuzz = true;
     bool enable_cdr_data_fuzz = true;
     bool enable_padding_fuzz = true;
     
     int max_fuzz_iterations = 100;
     int fuzz_delay_ms = 100;
     bool enable_random_fuzz = true;
     bool enable_boundary_fuzz = true;
     bool enable_corruption_fuzz = true;
     bool enable_submessage_insertion_fuzz = true; // 新增：启用submessage插入模糊测试
     
     // 异常检测配置
     bool enable_anomaly_detection = true;
     std::string expected_reception_log_file = "expected_receptions.log";  // 期望接收状态日志文件
 };
 
 // 漏洞测试配置结构体
 struct VulnerabilityTestConfig {
     bool enable_buffer_overflow_test = true;
     bool enable_boundary_test = true;
     bool enable_integer_overflow_test = true;
     bool enable_magic_header_corruption = true;
     bool enable_protocol_version_corruption = true;
     bool enable_guid_prefix_overflow = true;
     int test_iterations = 10;
     int delay_ms = 100;
 };
 
// 扩展的模糊测试配置结构体
struct ExtendedFuzzConfig {
    // 基础配置
    size_t max_fuzz_iterations = 100;
    uint32_t fuzz_delay_ms = 100;
    bool enable_anomaly_detection = true;
    std::string expected_reception_log_file = "extended_expected_receptions.log";
    
    // 变异策略配置
    bool enable_bit_flip_fuzz = true;
    bool enable_byte_swap_fuzz = true;
    bool enable_length_mutation_fuzz = true;
    bool enable_repetition_fuzz = true;
    bool enable_special_char_fuzz = true;
    bool enable_arithmetic_fuzz = true;
    bool enable_structural_fuzz = true;
    bool enable_time_based_fuzz = true;
    bool enable_entropy_fuzz = true;
    bool enable_pattern_fuzz = true;
    bool enable_combined_fuzz = true;
    bool enable_intelligent_fuzz = true;
    
    // 原有配置
    bool enable_random_fuzz = true;
    bool enable_boundary_fuzz = true;
    bool enable_corruption_fuzz = true;
    bool enable_submessage_insertion_fuzz = true;
    bool enable_magic_header_fuzz = true;
    bool enable_protocol_version_fuzz = true;
    bool enable_vendor_id_fuzz = true;
    bool enable_guid_prefix_fuzz = true;
    bool enable_submessage_fuzz = true;
    bool enable_flags_fuzz = true;
    bool enable_entity_id_fuzz = true;
    bool enable_sequence_number_fuzz = true;
    bool enable_timestamp_fuzz = true;
    bool enable_cdr_data_fuzz = true;
    bool enable_padding_fuzz = true;
    
    // 变异强度配置
    uint32_t bit_flip_rate = 10;           // 位翻转概率 (0-100)
    uint32_t special_char_injection_rate = 10; // 特殊字符注入概率 (0-100)
    uint32_t arithmetic_mutation_rate = 20;    // 算术变异概率 (0-100)
    uint32_t pattern_destruction_rate = 30;    // 模式破坏概率 (0-100)
    
    // 智能变异配置
    bool enable_field_specific_mutation = true;  // 启用字段特定变异
    bool enable_protocol_aware_mutation = true;  // 启用协议感知变异
    bool enable_context_sensitive_mutation = true; // 启用上下文敏感变异
};

// UDP监听配置结构体
struct UDPListenerConfig {
    int start_port = 7400;
    int end_port = 7500;
    bool enable_listening = true;
    std::string log_file = "udp_listener.log";
    int timeout_ms = 1000; // 监听超时时间
};

 /**
  * @brief FastDDS发布者测试类
  * 
  * 提供完整的发布者功能，包括：
  * - QoS配置管理
  * - 消息发布
  * - 连接状态监控
  */
 class TestPuberCore
 {
 public:
     // 发现的Writer信息结构体
     struct DiscoveredWriterInfo {
         GUID_t writer_guid;
         std::string source_ip;
         int source_port;
         std::chrono::system_clock::time_point discovery_time;
         std::string topic_name;
         std::string type_name;
     };
 private:
     HelloWorld hello_;
     DomainParticipant* participant_;
     Publisher* publisher_;
     Topic* topic_;
     DataWriter* writer_;
     TypeSupport type_;
     QoSManager qos_manager_;
 
    // 异常检测相关成员变量
    std::ofstream expected_reception_log_file_;

    // UDP监听相关成员变量
    std::atomic<bool> udp_listener_running_;
    std::thread udp_listener_thread_;
    std::vector<int> udp_sockets_;
    std::vector<DiscoveredWriterInfo> discovered_writers_;
    mutable std::mutex discovered_writers_mutex_;
    std::ofstream udp_listener_log_file_;
    UDPListenerConfig udp_listener_config_;
    // 最近监听到的对端报文的目的端口（本机端口），用于发送时复用同端口
    std::atomic<int> last_observed_dst_port_ {0};
    // 已观察到的目的端口集合（排除7400）
    std::set<int> observed_dst_ports_;
    mutable std::mutex observed_ports_mutex_;
 
     /**
      * @brief 数据写入监听器类
      * 
      * 处理发布匹配事件
      */
     class PubListener : public DataWriterListener
     {
     public:
         PubListener()
             : matched_(0)
         {
         }
 
         ~PubListener() override
         {
         }
 
         /**
          * @brief 发布匹配状态变化回调
          * @param writer 数据写入器
          * @param info 匹配状态信息
          */
         void on_publication_matched(
                 DataWriter*,
                 const PublicationMatchedStatus& info) override;
 
         std::atomic_int matched_;
     } listener_;
 
 public:
     /**
      * @brief 构造函数
      */
     TestPuberCore();
 
     /**
      * @brief 析构函数
      */
     virtual ~TestPuberCore();
 
     /**
      * @brief 设置QoS配置
      * @param config QoS配置
      */
     void setQoSConfig(const QoSConfig& config)
     {
         qos_manager_.setQoSConfig(config);
     }
 
     /**
      * @brief 获取QoS管理器
      * @return QoS管理器引用
      */
     QoSManager& getQoSManager()
     {
         return qos_manager_;
     }
 
     /**
      * @brief 初始化发布者
      * @return 初始化是否成功
      */
     bool init();
 
     /**
      * @brief 发布消息
      * @return 发布是否成功
      */
     bool publish();
 
     /**
      * @brief 运行发布者
      * @param samples 要发布的样本数量
      */
     void run(uint32_t samples);
 
     /**
      * @brief 配置发布者QoS策略
      * 
      * 设置各种QoS参数，包括：
      * - 可靠性策略
      * - Topic历史深度
      * - Topic持久性策略
      * - 分区配置
      * - 用户数据
      * - 时间相关参数
      * - 活跃性策略
      * - 所有权策略
      * - 发布模式
      * - 禁用正确认认
      */
     void configureQoS();
 
     /**
      * @brief 获取并打印GUID前缀信息
      * 
      * 打印Participant和DataWriter的GUID信息，包括：
      * - GUID前缀的完整字节序列
      * - VendorId、HostId、AppId、InstanceId的解析
      * - EntityId信息
      */
     void printGUIDInfo();
 
     /**
      * @brief 从JSON文件读取DataReader的GUID信息
      * 
      * 从Test2Suber.json文件中读取HostId、AppId和InstanceId，
      * 构建完整的DataReader GUID前缀，便于与Publisher的GUID进行对比分析。
      */
     void readDataReaderGUIDFromJson();
     void testHandmadeRTPSPacket();
     
     // 为HandmadeRTPSPacket提供GUID信息的公共方法
     GUID_t getWriterGUID() const;
     GUID_t getParticipantGUID() const;
     
     // JSON文件读取方法
     struct GUIDInfo {
         std::string host_id;
         std::string app_id;
         std::string instance_id;
     };
     GUIDInfo readGUIDFromJson(const std::string& json_file_path = "./build/Test2Suber.json") const;
     
     /**
      * @brief 发送UDP数据包
      * @param i 序列号参数，用于生成RTPS数据包
      * 
      * 将生成的RTPS数据包打包为UDP数据包并发送到指定目标
      * 源地址：127.0.0.1:45345
      * 目标地址：127.0.0.1:7413
      */
     void sendUDPPacket(int i);
 
     /**
      * @brief 发送带模糊测试的UDP数据包
      * @param usr_defined_seq_num 用户定义的序列号
      * 
      * 构建原始RTPS数据包，然后随机选择一个字段进行模糊测试修改，
      * 发送修改后的数据包而不是原始数据包
      */
     void sendUDPPacketWithFuzzing(int usr_defined_seq_num);
 
     // ==================== 模糊测试相关函数 ====================
     
     /**
      * @brief 执行字段级模糊测试
      * @param base_seq_num 基础序列号
      * 
      * 对RTPS数据包的各个字段进行模糊测试，包括：
      * - 随机数据模糊测试
      * - 边界值模糊测试
      * - 数据损坏模糊测试
      */
     void performFieldLevelFuzzing(int base_seq_num);
     
     /**
      * @brief 配置模糊测试参数
      * @param config 模糊测试配置结构体
      * 
      * 设置模糊测试的各种参数，包括：
      * - 最大测试次数
      * - 测试间隔
      * - 启用的模糊测试类型
      */
     void configureFuzzing(const struct FuzzConfig& config);
     
     /**
      * @brief 配置扩展模糊测试参数
      * @param config 扩展模糊测试配置结构体
      * 
      * 设置扩展模糊测试的各种参数，包括：
      * - 16种变异策略
      * - 变异强度配置
      * - 智能变异配置
      */
     void configureExtendedFuzzing(const struct ExtendedFuzzConfig& config);
     
     /**
      * @brief 执行完整的模糊测试流程
      * @param base_seq_num 基础序列号
      * @param num_iterations 测试迭代次数
      * 
      * 执行多轮字段级模糊测试，每轮使用不同的序列号
      */
     void runFuzzingTest(int base_seq_num, int num_iterations);
 
     // ==================== 异常检测相关方法 ====================
     
     /**
      * @brief 记录期望的接收状态到日志文件
      * @param seq_num 序列号
      * @param should_receive 是否应该接收
      * @param fuzz_description 模糊测试描述
      * @param field_description 字段描述
      */
     void logExpectedReception(int seq_num, bool should_receive, 
                              const std::string& fuzz_description, 
                              const std::string& field_description);
     
     /**
      * @brief 根据模糊测试类型判断期望接收状态
      * @param fuzz_type 模糊测试类型 (0=随机, 1=边界值, 2=数据损坏, 3=submessage插入)
      * @param field_type 字段类型
      * @return 是否应该接收
      */
     bool determineExpectedReception(int fuzz_type, FieldType field_type);
     
     /**
      * @brief 获取当前时间戳字符串
      * @return 时间戳字符串
      */
     std::string getCurrentTimestamp() const;
 
     // ==================== 漏洞测试相关方法 ====================
     
     /**
      * @brief 配置漏洞测试参数
      * @param config 漏洞测试配置结构体
      * 
      * 设置漏洞测试的各种参数，包括：
      * - 缓冲区溢出测试
      * - 边界条件测试
      * - 整数溢出测试
      * - Magic Header损坏测试
      * - 协议版本损坏测试
      * - GUID前缀溢出测试
      */
     void configureVulnerabilityTesting(const VulnerabilityTestConfig& config);
     
     /**
      * @brief 运行漏洞测试
      * 
      * 执行针对checkRTPSHeader函数的漏洞测试套件，包括：
      * - 缓冲区溢出测试
      * - 边界条件测试
      * - 整数溢出测试
      * - Magic Header损坏测试
      * - 协议版本损坏测试
      * - GUID前缀溢出测试
      */
     void runVulnerabilityTests(int test_id);
     
     // ==================== DATA_FRAG下溢测试相关方法 ====================
     
     /**
      * @brief 生成DATA_FRAG下溢测试数据包
      * @param seq_num 序列号
      * @param target_guid 目标GUID（可选，如果为空则使用默认GUID）
      * @return 构造的RTPS数据包
      * 
      * 构造一个DATA_FRAG子消息，通过大的内联QoS数据触发payload_size计算的下溢
      */
     std::vector<char> generateDataFragUnderflowPacket(int seq_num, const GUID_t* target_guid = nullptr);
     
     /**
      * @brief 生成极端DATA_FRAG下溢测试数据包
      * @return 构造的RTPS数据包
      * 
      * 构造一个更大的DATA_FRAG子消息，使用更大的内联QoS数据触发更严重的下溢
      */
     std::vector<char> generateExtremeDataFragUnderflowPacket(int seq_num);
     
     /**
      * @brief 运行DATA_FRAG下溢漏洞测试套件
      * 
      * 执行针对proc_Submsg_DataFrag函数的整数下溢漏洞测试
      */
     void runDataFragUnderflowTestSuite(int test_id);
     void sendVulnerabilityTestPacket(const std::vector<char>& packet, const std::string& test_name, int test_id);
     /**
      * @brief 生成指定的十六进制字符串
      * @return 包含指定十六进制数据的字符向量
      * 
      * 生成内容为 00 01 00 03 00 00 00 00 09 00 00 00 41 42 43 44 45 46 47 48 49 00 00 00 的字符串
      */
     std::vector<char> generateSpecificHexString();
     
     /**
      * @brief 生成指定的十六进制字符串（转义版本，安全用于字符串）
      * @return 包含指定十六进制数据的转义字符串
      * 
      * 生成内容为 00 01 00 03 00 00 00 00 09 00 00 00 41 42 43 44 45 46 47 48 49 00 00 00 的转义字符串
      * 将null字符和其他特殊字符进行转义，确保字符串可以安全使用
      */
     std::string generateSpecificHexStringEscaped();

     // ==================== UDP监听相关方法 ====================
     
     /**
      * @brief 配置UDP监听器
      * @param config UDP监听配置
      */
     void configureUDPListener(const UDPListenerConfig& config);
     
     /**
      * @brief 启动UDP监听器
      * @return 启动是否成功
      */
     bool startUDPListener();
     bool startRawListener();
     
     /**
      * @brief 停止UDP监听器
      */
     void stopUDPListener();
     
     /**
      * @brief UDP监听线程主函数
      */
     void udpListenerThreadFunction();
     void rawListenerThreadFunction();
     
     /**
      * @brief 解析RTPS数据包并提取Writer GUID
      * @param packet_data 数据包数据
      * @param packet_size 数据包大小
      * @param source_ip 源IP地址
      * @param source_port 源端口
      * @param writer_info 输出参数，解析出的Writer信息
      * @return 解析是否成功
      */
     bool parseRTPSPacket(const char* packet_data, 
                         size_t packet_size,
                         const std::string& source_ip,
                         int source_port,
                         DiscoveredWriterInfo& writer_info);
     
     /**
      * @brief 获取发现的Writer列表
      * @return 发现的Writer信息列表
      */
     std::vector<DiscoveredWriterInfo> getDiscoveredWriters();
     
     /**
      * @brief 打印发现的Writer信息
      */
     void printDiscoveredWriters() const;
 };
 
    /**
     * @brief 手工构建RTPS数据包的辅助类
     * 
     * 用于构建符合RTPS协议的数据包，支持尽力交付模式
     */
    class HandmadeRTPSPacket
    {
    private:
        TestPuberCore* puber_; // 指向TestPuber的指针，用于获取DataWriter信息
        const GUID_t* external_guid_; // 外部提供的GUID（可选）
        
    public:
        HandmadeRTPSPacket(TestPuberCore* puber = nullptr, const GUID_t* external_guid = nullptr) 
            : puber_(puber), external_guid_(external_guid) {}
        char* magic_head(char* magic_head); // 一般为4字节，表示"RTPS"
        char* protocol_version(char* protocol_version); // protocolVersion，2字节，一般2.2
        char* vendorId(char* vendor_id); // 从DataWriter获取vendorId
        char* guidprefix(char* guid_prefix); // 从DataWriter获取完整的guidprefix
        char* submessageId_Info_Dst(char* Info_Dst, char* flags, char* octetsToNextHeader); // 从JSON文件读取dst_guidprefix
        char* generateUTCTimestamp(char* timestamp); // 生成当前UTC时间戳（8字节）
        char* serializeCDR_LE(const HelloWorld& data, int& data_length); // CDR_LE序列化HelloWorld数据
        char* submessageId_Info_TS(char* Info_TS, char* flags, char* octetsToNextHeader, char* timestamp); // 构建submessage_Info_TS，注意开头有1字节的标识，用于标识Info_TS，另外timestamp为8字节UTC时间戳
        char* submessageId_Info_DATA(char* Info_DATA, char* flags, char* octetsToNextHeader, char* extra_flags , char* octetsToInlineQos, char* readerEntityId, char* writerEntityId, char* writerSequenceNumber, char* CDR_LE_serializedData, int cdr_data_length); // 构建submessage_Info_DATA，注意开头有1字节的标识，flags1字节，一般0x05表示Data Present Endianess，用于标识Info_DATA，extra_flags为2字节，一般全0，octetsToInlineQos为4字节，用于标识InlineQos，readerEntityId为8字节，用于标识ReaderEntityId，writerEntityId为8字节，用于标识WriterEntityId，writerSequenceNumber为8字节，用于标识WriterSequenceNumber，CDR_LE_serializedData为数据
    };
 
 /**
  * @brief 辅助函数：创建Duration_t对象
  * @param seconds 秒数
  * @param nanoseconds 纳秒数
  * @return Duration_t对象
  */
 Duration_t createDuration(int32_t seconds, uint32_t nanoseconds);
 
 #endif // TESTPUBER_HPP 