// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file TestSuber.cpp
 *
 * 此文件由Python脚本自动生成，请勿手动修改。
 */

#include "TestSuber.hpp"
#include <fastdds/rtps/transport/UDPv4TransportDescriptor.hpp>

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;

// 消息数组（Fuzz测试用，便于后续校验）
const char* fuzz_messages[] = {"FuzzMsg0", "FuzzMsg1", "FuzzMsg2", "FuzzMsg3", "FuzzMsg4", "FuzzMsg5", "FuzzMsg6", "FuzzMsg7", "FuzzMsg8", "FuzzMsg9", "FuzzMsg10", "FuzzMsg11", "FuzzMsg12", "FuzzMsg13", "FuzzMsg14", "FuzzMsg15", "FuzzMsg16", "FuzzMsg17", "FuzzMsg18", "FuzzMsg19"};
const size_t fuzz_message_count = sizeof(fuzz_messages)/sizeof(fuzz_messages[0]);

// 实现SubListener的方法
void TestSuber::SubListener::on_subscription_matched(
    DataReader *,
    const SubscriptionMatchedStatus &info)
{
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    
    if (info.current_count_change == 1)
    {
        matched_ = info.total_count;
        std::cout << "[" << time_ms << "] Subscriber matched. (PID: " << getpt() << ")" << std::endl;
    }
    else if (info.current_count_change == -1)
    {
        matched_ = info.total_count;
        std::cout << "[" << time_ms << "] Subscriber unmatched. (PID: " << getpt() << ")" << std::endl;
    }
    else
    {
        std::cout << "[" << time_ms << "] " << info.current_count_change
                  << " is not a valid value for SubscriptionMatchedStatus current count change" << std::endl;
    }
}

void TestSuber::SubListener::on_data_available(
    DataReader *reader)
{
    SampleInfo info;
    if (reader->take_next_sample(&hello_, &info) == eprosima::fastdds::dds::RETCODE_OK)
    {
        if (info.valid_data)
        {
            samples_++;
            auto now = std::chrono::steady_clock::now();
            auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
            std::cout << "[" << time_ms << "] Message:  with index: " << hello_.index()
                      << " RECEIVED. (Total: " << samples_ << ")" << std::endl;
            
            // // 检查 ResourceLimits 是否生效
            // if (samples_ > 10) {
            //     std::cout << "[" << time_ms << "] WARNING: ResourceLimits exceeded! samples_ = " << samples_ << std::endl;
            // }
        }
    }
}

// 实现TestSuber的方法
TestSuber::TestSuber()
    : participant_(nullptr), subscriber_(nullptr), topic_(nullptr), reader_(nullptr), type_(new HelloWorldPubSubType())
{
}

TestSuber::~TestSuber()
{
    if (reader_ != nullptr)
    {
        subscriber_->delete_datareader(reader_);
    }
    if (topic_ != nullptr)
    {
        participant_->delete_topic(topic_);
    }
    if (subscriber_ != nullptr)
    {
        participant_->delete_subscriber(subscriber_);
    }
    DomainParticipantFactory::get_instance()->delete_participant(participant_);
}

bool TestSuber::init()
{
    DomainParticipantQos participantQos;
    participantQos.name("Participant_subscriber1");
    
    // 创建UDP传输描述符
    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();
    
    // 清除默认传输并添加UDP传输
    participantQos.transport().use_builtin_transports = false;
    participantQos.transport().user_transports.push_back(udp_transport);
    
    participant_ = DomainParticipantFactory::get_instance()->create_participant(0, participantQos);

    if (participant_ == nullptr)
    {
        return false;
    }

    // Register the Type
    type_.register_type(participant_);

    // Create the subscriptions Topic
    TopicQos tqos;
    qos_manager_.applyTopicQoS(tqos);

    topic_ = participant_->create_topic("WorkspaceHelloWorldTopic", "HelloWorld", tqos);

    if (topic_ == nullptr)
    {
        return false;
    }

    // Create the Subscriber
    SubscriberQos sqos;
    qos_manager_.applySubscriberQoS(sqos);
    subscriber_ = participant_->create_subscriber(sqos, nullptr);

    if (subscriber_ == nullptr)
    {
        return false;
    }

    // Create the DataReader
    DataReaderQos rqos;
    qos_manager_.applyDataReaderQoS(rqos);

    reader_ = subscriber_->create_datareader(topic_, rqos, &listener_);

    if (reader_ == nullptr)
    {
        return false;
    }

    return true;
}

void TestSuber::run(uint32_t samples)
{
    std::cout << "等待Publisher连接..." << std::endl;
    
    // 等待匹配的Publisher
    int wait_count = 0;
    const int max_wait = 3000; // 最多等待3000次，每次10毫秒
    while (listener_.matched_ == 0 && wait_count < max_wait)
    {
        std::cout << "等待匹配中... (" << wait_count + 1 << "/" << max_wait << ")" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(2)); // 改为10毫秒，提高响应速度
        wait_count++;
    }
    //跳出循环的时间戳打印
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    std::cout << "跳出循环的时间戳: " << time_ms << std::endl;
    // if (listener_.matched_ == 0)
    // {
    //     std::cout << "警告：没有找到匹配的Publisher，但仍将继续等待消息..." << std::endl;
    // }
    // else
    // {
    //     std::cout << "成功匹配到 " << listener_.matched_ << " 个Publisher" << std::endl;
    // }

    int check_count = 0;
    while (true)
    {
        check_count++;
        auto current_samples = listener_.samples_.load();
        auto now = std::chrono::steady_clock::now();
        auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
        std::cout << "[" << time_ms << "] 检查 #" << check_count << ": samples_ = " << current_samples << " (目标: " << samples << ")" << std::endl;
        
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    
    std::cout << "已接收 " << listener_.samples_ << " 条消息，程序结束。" << std::endl;
}

void TestSuber::configureQoS()
{
    // 获取QoS管理器并配置各种QoS策略
    QoSManager& qos_manager = getQoSManager();
    
    std::cout << "\n=== 配置Subscriber QoS策略 ===" << std::endl;
    
    // 1. 可靠性策略配置（必须与Publisher匹配）
    std::cout << "1. 设置可靠性策略..." << std::endl;
    qos_manager.setReliability(BEST_EFFORT_RELIABILITY_QOS);
    
    // 2. Topic历史深度配置
    std::cout << "2. 设置Topic历史深度..." << std::endl;
    qos_manager.setTopicHistoryDepth(20);
    
    // 3. Topic持久性策略配置
    std::cout << "3. 设置Topic持久性策略..." << std::endl;
    qos_manager.setTopicDurability(VOLATILE_DURABILITY_QOS);
    
    // 4. 分区配置（必须与Publisher匹配）
    std::cout << "4. 设置分区名称..." << std::endl;
    qos_manager.setPartition("wtest_partition");
    
    // 5. 用户数据配置
    std::cout << "5. 设置用户数据..." << std::endl;
    const uint8_t user_data[] = {1,2,3,4,5};
    qos_manager.setUserData(std::vector<uint8_t>(user_data, user_data + sizeof(user_data)/sizeof(user_data[0])));
    
    // 6. 时间相关配置
    std::cout << "6. 设置时间相关参数..." << std::endl;
    
    // 截止时间
    Duration_t deadline_period;
    deadline_period.seconds = 3600;
    deadline_period.nanosec = 0;
    qos_manager.setDeadline(deadline_period);
    
    // 生命周期
    Duration_t lifespan_duration;
    lifespan_duration.seconds = 3600;
    lifespan_duration.nanosec = 0;
    qos_manager.setLifespan(lifespan_duration);
    
    // 延迟预算
    Duration_t latency_budget;
    latency_budget.seconds = 1000000000000000000;
    latency_budget.nanosec = 100000;
    qos_manager.setLatencyBudget(latency_budget);
    
    // 7. 活跃性策略配置（必须与Publisher匹配）
    std::cout << "7. 设置活跃性策略..." << std::endl;
    qos_manager.setLiveliness(AUTOMATIC_LIVELINESS_QOS, createDuration(10, 0));
    
    // 8. 所有权策略配置（必须与Publisher匹配）
    std::cout << "8. 设置所有权策略..." << std::endl;
    qos_manager.setOwnership(SHARED_OWNERSHIP_QOS, 9999999999999999999999999999999999999999999);
    
    // 9. 基于时间的过滤配置（仅Subscriber）
    std::cout << "9. 设置基于时间的过滤..." << std::endl;
    Duration_t time_filter;
    time_filter.seconds = 0;
    time_filter.nanosec = 100000;
    qos_manager.setTimeBasedFilter(time_filter);
    
    // 10. 禁用正确认认配置（必须与Publisher匹配）
    std::cout << "10. 设置禁用正确认认..." << std::endl;
    Duration_t disable_duration;
    disable_duration.seconds = 0;
    disable_duration.nanosec = 0;
    qos_manager.setDisablePositiveAcks(false, disable_duration);
    
    // 11. 资源限制策略配置
    std::cout << "11. 设置资源限制策略..." << std::endl;
    qos_manager.setResourceLimits(10, 5, 10);
    
    // 12. 资源分配策略配置
    std::cout << "12. 设置资源分配策略..." << std::endl;
    qos_manager.setResourceAllocation(20, 10, 20);
    
    // 13. 主题数据配置
    std::cout << "13. 设置主题数据..." << std::endl;
    const uint8_t topic_data[] = {5, 6, 7, 8, 9};
    qos_manager.setTopicData(std::vector<uint8_t>(topic_data, topic_data + sizeof(topic_data)/sizeof(topic_data[0])));
    
    // 14. 组数据配置
    std::cout << "14. 设置组数据..." << std::endl;
    const uint8_t group_data[] = {10, 11, 12, 13, 14};
    qos_manager.setGroupData(std::vector<uint8_t>(group_data, group_data + sizeof(group_data)/sizeof(group_data[0])));
    
    // 15. 表示策略配置
    std::cout << "15. 设置表示策略..." << std::endl;
    qos_manager.setPresentation(TOPIC_PRESENTATION_QOS, true, false);
    
    // 16. 目标顺序策略配置
    std::cout << "16. 设置目标顺序策略..." << std::endl;
    qos_manager.setDestinationOrder(BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS);
    
    // 17. 数据表示配置
    std::cout << "17. 设置数据表示..." << std::endl;
    qos_manager.setDataRepresentation(XCDR_DATA_REPRESENTATION);
    
    // 18. 类型一致性强制配置
    std::cout << "18. 设置类型一致性强制..." << std::endl;
    qos_manager.setTypeConsistencyEnforcement(DISALLOW_TYPE_COERCION);
    
    // 19. 读取者数据生命周期配置
    std::cout << "19. 设置读取者数据生命周期..." << std::endl;
    Duration_t reader_autopurge_nowriter_delay;
    reader_autopurge_nowriter_delay.seconds = 0;
    reader_autopurge_nowriter_delay.nanosec = 0;
    
    Duration_t reader_autopurge_disposed_delay;
    reader_autopurge_disposed_delay.seconds = 0;
    reader_autopurge_disposed_delay.nanosec = 0;
    
    qos_manager.setReaderDataLifecycle(reader_autopurge_nowriter_delay, reader_autopurge_disposed_delay, false);
    
    std::cout << "QoS配置完成！" << std::endl;
}

// 辅助函数：创建Duration_t对象
Duration_t createDuration(int32_t seconds, uint32_t nanoseconds)
{
    Duration_t duration;
    duration.seconds = seconds;
    duration.nanosec = nanoseconds;
    return duration;
}

int main(
    int argc,
    char **argv)
{
    std::cout << "Starting subscriber." << std::endl;
    uint32_t samples = 0;

    TestSuber *mysub = new TestSuber();
    
    // 配置QoS策略
    mysub->configureQoS();
    
    if (mysub->init())
    {
        mysub->run(samples);
    }

    delete mysub;
    return 0;
} 