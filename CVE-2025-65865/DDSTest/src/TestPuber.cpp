// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file TestPuber.cpp
 *
 * 此文件由Python脚本自动生成，请勿手动修改。
 */

#include "TestPuber.hpp"
#include <fastdds/rtps/transport/UDPv4TransportDescriptor.hpp>

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastdds::rtps;

// 发布间隔常量（毫秒）
const uint32_t PUBLISH_INTERVAL_MS = 1;

// 消息数组（Fuzz测试用）
const char* fuzz_messages[] = {"FuzzMsg0", "FuzzMsg1", "FuzzMsg2", "FuzzMsg3", "FuzzMsg4", "FuzzMsg5", "FuzzMsg6", "FuzzMsg7", "FuzzMsg8", "FuzzMsg9", "FuzzMsg10", "FuzzMsg11", "FuzzMsg12", "FuzzMsg13", "FuzzMsg14", "FuzzMsg15", "FuzzMsg16", "FuzzMsg17", "FuzzMsg18", "FuzzMsg19"};
const size_t fuzz_message_count = sizeof(fuzz_messages)/sizeof(fuzz_messages[0]);

// 实现PubListener的方法
void TestPuber::PubListener::on_publication_matched(
        DataWriter*,
        const PublicationMatchedStatus& info)
{
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    
    if (info.current_count_change == 1)
    {
        matched_ = info.total_count;
        std::cout << "[" << time_ms << "] Publisher matched. (PID: " << getpt() << ")" << std::endl;
    }
    else if (info.current_count_change == -1)
    {
        matched_ = info.total_count;
        std::cout << "[" << time_ms << "] Publisher unmatched. (PID: " << getpt() << ")" << std::endl;
    }
    else
    {
        std::cout << "[" << time_ms << "] " << info.current_count_change
                << " is not a valid value for PublicationMatchedStatus current count change." << std::endl;
    }
}

// 实现TestPuber的方法
TestPuber::TestPuber()
    : participant_(nullptr)
    , publisher_(nullptr)
    , topic_(nullptr)
    , writer_(nullptr)
    , type_(new HelloWorldPubSubType())
{
}

TestPuber::~TestPuber()
{
    if (writer_ != nullptr)
    {
        publisher_->delete_datawriter(writer_);
    }
    if (publisher_ != nullptr)
    {
        participant_->delete_publisher(publisher_);
    }
    if (topic_ != nullptr)
    {
        participant_->delete_topic(topic_);
    }
    DomainParticipantFactory::get_instance()->delete_participant(participant_);
}

bool TestPuber::init()
{
    std::cout << "开始初始化Publisher..." << std::endl;
    
    DomainParticipantQos participantQos;
    participantQos.name("Participant_publisher1");
    
    // 创建UDP传输描述符
    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();
    
    // 清除默认传输并添加UDP传输
    participantQos.transport().use_builtin_transports = false;
    participantQos.transport().user_transports.push_back(udp_transport);
    
    std::cout << "创建DomainParticipant..." << std::endl;
    participant_ = DomainParticipantFactory::get_instance()->create_participant(0, participantQos);

    if (participant_ == nullptr)
    {
        std::cout << "DomainParticipant创建失败！" << std::endl;
        return false;
    }
    std::cout << "DomainParticipant创建成功" << std::endl;

    // Register the Type
    std::cout << "注册类型..." << std::endl;
    type_.register_type(participant_);
    std::cout << "类型注册完成" << std::endl;

    // Create the publications Topic
    std::cout << "创建Topic..." << std::endl;
    TopicQos tqos;
    std::cout << "应用Topic QoS配置..." << std::endl;
    try {
        qos_manager_.applyTopicQoS(tqos);
        std::cout << "  ✓ Topic QoS应用成功" << std::endl;
    } catch (const std::exception& e) {
        std::cout << "  ✗ Topic QoS应用失败: " << e.what() << std::endl;
        return false;
    }

    topic_ = participant_->create_topic("WorkspaceHelloWorldTopic", "HelloWorld", tqos);

    if (topic_ == nullptr)
    {
        std::cout << "Topic创建失败！" << std::endl;
        return false;
    }
    std::cout << "Topic创建成功" << std::endl;

    // Create the Publisher
    std::cout << "创建Publisher..." << std::endl;
    PublisherQos pqos;
    std::cout << "应用Publisher QoS配置..." << std::endl;
    try {
        qos_manager_.applyPublisherQoS(pqos);
        std::cout << "  ✓ Publisher QoS应用成功" << std::endl;
    } catch (const std::exception& e) {
        std::cout << "  ✗ Publisher QoS应用失败: " << e.what() << std::endl;
        return false;
    }
    publisher_ = participant_->create_publisher(pqos, nullptr);

    if (publisher_ == nullptr)
    {
        std::cout << "Publisher创建失败！" << std::endl;
        return false;
    }
    std::cout << "Publisher创建成功" << std::endl;

    // Create the DataWriter
    std::cout << "创建DataWriter..." << std::endl;
    DataWriterQos wqos;
    std::cout << "应用DataWriter QoS配置..." << std::endl;
    try {
        qos_manager_.applyDataWriterQoS(wqos);
        std::cout << "  ✓ DataWriter QoS应用成功" << std::endl;
    } catch (const std::exception& e) {
        std::cout << "  ✗ DataWriter QoS应用失败: " << e.what() << std::endl;
        return false;
    }

    // 添加超时机制
    std::cout << "开始创建DataWriter，设置10秒超时..." << std::endl;
    auto start_time = std::chrono::steady_clock::now();
    
    // 临时移除监听器，测试是否是监听器导致的问题
    //writer_ = publisher_->create_datawriter(topic_, wqos, nullptr);
    writer_ = publisher_->create_datawriter(topic_, wqos, &listener_);
    
    auto end_time = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time);
    std::cout << "DataWriter创建耗时: " << duration.count() << " 秒" << std::endl;

    if (writer_ == nullptr)
    {
        std::cout << "DataWriter创建失败！" << std::endl;
        return false;
    }
    std::cout << "DataWriter创建成功" << std::endl;
    std::cout << "Publisher初始化完成！" << std::endl;
    return true;
}

bool TestPuber::publish()
{
    if (listener_.matched_ > 0)
    {
        hello_.index(hello_.index() + 1);
        writer_->write(&hello_);
        return true;
    }
    return false;
}

void TestPuber::run(uint32_t samples)
{
    std::cout << "等待Subscriber连接..." << std::endl;
    
    // 等待匹配的Subscriber
    int wait_count = 0;
    const int max_wait = 3000; // 最多等待3000次，每次10毫秒
    while (listener_.matched_ == 0 && wait_count < max_wait)
    {
        std::cout << "等待匹配中... (" << wait_count + 1 << "/" << max_wait << ")" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(2)); // 改为10毫秒，提高响应速度
        wait_count++;
    }
    //跳出循环的时间戳打印
    auto now = std::chrono::steady_clock::now();
    auto time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    std::cout << "跳出循环的时间戳: " << time_ms << std::endl;
    if (listener_.matched_ == 0)
    {
        std::cout << "警告：没有找到匹配的Subscriber，但仍将继续发送消息..." << std::endl;
    }
    else
    {
        std::cout << "成功匹配到 " << listener_.matched_ << " 个Subscriber" << std::endl;
    }
    int index = 0;
    // 方式一：批量发送Fuzz消息（数组+循环方式，推荐Fuzz）
    while (true) {
        std::stringstream ss;
        ss << std::string(100, '1');
        hello_.message(ss.str());
        hello_.index(index);
        index++;
        if (!writer_->write(&hello_)) {
            std::cout << "Message:  with index: " << hello_.index() << " SENT." << std::endl;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(PUBLISH_INTERVAL_MS));
    }

    // 方式二：逐条动态切换消息内容（动态切换方式，兼容原有publish逻辑）
    /*
    uint32_t samples_sent = 0;
    while (samples_sent < samples)
    {
        if (publish())
        {
            samples_sent++;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(2000));
    }
    */
}

void TestPuber::configureQoS()
{
    // 获取QoS管理器并配置各种QoS策略
    QoSManager& qos_manager = getQoSManager();
    
    std::cout << "\n=== 配置Publisher QoS策略 ===" << std::endl;
    
    // 1. 可靠性策略配置
    std::cout << "1. 设置可靠性策略..." << std::endl;
    qos_manager.setReliability(BEST_EFFORT_RELIABILITY_QOS);
    
    // 2. Topic历史深度配置
    std::cout << "2. 设置Topic历史深度..." << std::endl;
    qos_manager.setTopicHistoryDepth(20);
    
    // 3. Topic持久性策略配置
    std::cout << "3. 设置Topic持久性策略..." << std::endl;
    qos_manager.setTopicDurability(VOLATILE_DURABILITY_QOS);
    
    // 4. 分区配置
    std::cout << "4. 设置分区名称..." << std::endl;
    qos_manager.setPartition("wtest_partition");
    
    // 5. 用户数据配置
    std::cout << "5. 设置用户数据..." << std::endl;
    const uint8_t user_data[] = {1,2,3,4,5};
    qos_manager.setUserData(std::vector<uint8_t>(user_data, user_data + sizeof(user_data)/sizeof(user_data[0])));
    
    // 6. 时间相关配置
    std::cout << "6. 设置时间相关参数..." << std::endl;
    
    // 截止时间
    Duration_t deadline_period;
    deadline_period.seconds = 3600;
    deadline_period.nanosec = 0;
    qos_manager.setDeadline(deadline_period);
    
    // 生命周期
    Duration_t lifespan_duration;
    lifespan_duration.seconds = 3600;
    lifespan_duration.nanosec = 0;
    qos_manager.setLifespan(lifespan_duration);
    
    // 延迟预算
    Duration_t latency_budget;
    latency_budget.seconds = 1000000000000000000;
    latency_budget.nanosec = 100000; // 改为999ms，原来是1000000000（1秒）
    qos_manager.setLatencyBudget(latency_budget);
    std::cout << "   延迟预算配置完成" << std::endl;
    
    // 7. 活跃性策略配置
    std::cout << "7. 设置活跃性策略..." << std::endl;
    qos_manager.setLiveliness(AUTOMATIC_LIVELINESS_QOS, createDuration(10, 0));
    
    // 8. 所有权策略配置
    std::cout << "8. 设置所有权策略..." << std::endl;
    qos_manager.setOwnership(SHARED_OWNERSHIP_QOS, 999999);
    
    // 9. 发布模式配置
    std::cout << "9. 设置发布模式..." << std::endl;
    qos_manager.setPublishMode(SYNCHRONOUS_PUBLISH_MODE);
    
    // 10. 禁用正确认认配置
    std::cout << "10. 设置禁用正确认认..." << std::endl;
    Duration_t disable_duration;
    disable_duration.seconds = 0;
    disable_duration.nanosec = 0;
    qos_manager.setDisablePositiveAcks(false, disable_duration);
    
    // 11. 资源限制策略配置
    std::cout << "11. 设置资源限制策略..." << std::endl;
    qos_manager.setResourceLimits(10, 5, 10);
    
    // 12. 资源分配策略配置
    std::cout << "12. 设置资源分配策略..." << std::endl;
    qos_manager.setResourceAllocation(20, 10, 20);
    
    // 13. 主题数据配置
    std::cout << "13. 设置主题数据..." << std::endl;
    const uint8_t topic_data[] = {5, 6, 7, 8, 9};
    qos_manager.setTopicData(std::vector<uint8_t>(topic_data, topic_data + sizeof(topic_data)/sizeof(topic_data[0])));
    
    // 14. 组数据配置
    std::cout << "14. 设置组数据..." << std::endl;
    const uint8_t group_data[] = {10, 11, 12, 13, 14};
    qos_manager.setGroupData(std::vector<uint8_t>(group_data, group_data + sizeof(group_data)/sizeof(group_data[0])));
    
    // 15. 表示策略配置
    std::cout << "15. 设置表示策略..." << std::endl;
    qos_manager.setPresentation(TOPIC_PRESENTATION_QOS, true, false);
    
    // 16. 目标顺序策略配置
    std::cout << "16. 设置目标顺序策略..." << std::endl;
    qos_manager.setDestinationOrder(BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS);
    
    // 17. 传输优先级配置
    std::cout << "17. 设置传输优先级..." << std::endl;
    qos_manager.setTransportPriority(5);
    
    // 18. 持久性服务配置
    std::cout << "18. 设置持久性服务..." << std::endl;
    qos_manager.setDurabilityService(KEEP_LAST_HISTORY_QOS, 1, 
                                   200, 40, 
                                   50);
    
    // 19. 数据表示配置
    std::cout << "19. 设置数据表示..." << std::endl;
    qos_manager.setDataRepresentation(XCDR_DATA_REPRESENTATION);
    
    // 20. 类型一致性强制配置
    std::cout << "20. 设置类型一致性强制..." << std::endl;
    qos_manager.setTypeConsistencyEnforcement(DISALLOW_TYPE_COERCION);
    
    // 21. 写入者数据生命周期配置
    std::cout << "21. 设置写入者数据生命周期..." << std::endl;
    Duration_t writer_autopurge_delay;
    writer_autopurge_delay.seconds = 0;
    writer_autopurge_delay.nanosec = 0;
    qos_manager.setWriterDataLifecycle(true, writer_autopurge_delay);
    
    std::cout << "QoS配置完成！" << std::endl;
}

// 辅助函数：创建Duration_t对象
Duration_t createDuration(int32_t seconds, uint32_t nanoseconds)
{
    Duration_t duration;
    duration.seconds = seconds;
    duration.nanosec = nanoseconds;
    return duration;
}

int main(
        int argc,
        char** argv)
{
    std::cout << "Starting publisher." << std::endl;
    uint32_t samples = 20;

    TestPuber* mypub = new TestPuber();
    std::cout << "TestPuber created." << std::endl;
    
    mypub->configureQoS();
    std::cout << "QoS configured." << std::endl;
    
    if(mypub->init())
    {
        std::cout << "Init success, running..." << std::endl;
        mypub->run(samples);
    }
    else
    {
        std::cout << "Init failed." << std::endl;
    }

    std::cout << "About to delete mypub..." << std::endl;
    delete mypub;
    std::cout << "mypub deleted, exiting." << std::endl;
    return 0;
} 