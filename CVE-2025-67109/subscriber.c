#include "dds/dds.h"
#include "TestData.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* Message array (samples in DDS terminology) */
#define MAX_SAMPLES 1

int main(int argc, char **argv)
{
    dds_entity_t participant;
    dds_entity_t topic;
    dds_entity_t reader;
    TestData_Message *msg;
    void *samples[MAX_SAMPLES];
    dds_sample_info_t infos[MAX_SAMPLES];
    dds_return_t rc;
    dds_qos_t *qos;
    (void)argc;
    (void)argv;

    // Get current working directory, construct absolute paths for certificates and configuration files
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        fprintf(stderr, "Error: Unable to get current working directory\n");
        return EXIT_FAILURE;
    }
    
    // Check if in build/bin directory, if so go up two levels to project root
    char certs_dir[2048];
    char etc_dir[2048];
    char certs_dir_abs[2048];
    char etc_dir_abs[2048];
    
    if (strstr(cwd, "/build/bin") != NULL || strstr(cwd, "/build") != NULL) {
        // In build directory, go up two levels to project root
        snprintf(certs_dir, sizeof(certs_dir), "%s/../certs", cwd);
        snprintf(etc_dir, sizeof(etc_dir), "%s/../etc", cwd);
    } else {
        // In project root directory
        snprintf(certs_dir, sizeof(certs_dir), "%s/certs", cwd);
        snprintf(etc_dir, sizeof(etc_dir), "%s/etc", cwd);
    }
    
    // Convert to absolute paths
    if (realpath(certs_dir, certs_dir_abs) == NULL) {
        fprintf(stderr, "Error: Unable to resolve certificate directory path\n");
        return EXIT_FAILURE;
    }
    if (realpath(etc_dir, etc_dir_abs) == NULL) {
        fprintf(stderr, "Error: Unable to resolve configuration directory path\n");
        return EXIT_FAILURE;
    }
    
    // Set CycloneDDS configuration, enable security encryption
    char config[4096];
    snprintf(config, sizeof(config),
        "<CycloneDDS>"
        "  <Domain id=\"any\">"
        "    <Discovery>"
        "      <ExternalDomainId>0</ExternalDomainId>"
        "    </Discovery>"
        "    <Security>"
        "      <Authentication>"
        "        <Library initFunction=\"init_authentication\" finalizeFunction=\"finalize_authentication\" path=\"dds_security_auth\"/>"
        "        <IdentityCertificate>file:%s/example_subscriber_cert.pem</IdentityCertificate>"
        "        <PrivateKey>file:%s/example_subscriber_priv_key.pem</PrivateKey>"
        "        <IdentityCA>file:%s/example_id_ca_cert.pem</IdentityCA>"
        "      </Authentication>"
        "      <Cryptographic>"
        "        <Library initFunction=\"init_crypto\" finalizeFunction=\"finalize_crypto\" path=\"dds_security_crypto\"/>"
        "      </Cryptographic>"
        "      <AccessControl>"
        "        <Library initFunction=\"init_access_control\" finalizeFunction=\"finalize_access_control\" path=\"dds_security_ac\"/>"
        "        <PermissionsCA>file:%s/example_perm_ca_cert.pem</PermissionsCA>"
        "        <Governance>file:%s/example_governance.p7s</Governance>"
        "        <Permissions>file:%s/example_subscriber_permissions.p7s</Permissions>"
        "      </AccessControl>"
        "    </Security>"
        "  </Domain>"
        "</CycloneDDS>",
        certs_dir_abs, certs_dir_abs, certs_dir_abs,
        certs_dir_abs, etc_dir_abs, etc_dir_abs);

    // Set environment variable
    setenv("CYCLONEDDS_URI", config, 1);

    printf("=== [Subscriber] Creating participant...\n");
    fflush(stdout);

    /* Create participant */
    participant = dds_create_participant(DDS_DOMAIN_DEFAULT, NULL, NULL);
    if (participant < 0)
    {
        fprintf(stderr, "Error: dds_create_participant: %s\n", dds_strretcode(-participant));
        return EXIT_FAILURE;
    }

    printf("=== [Subscriber] Creating topic...\n");
    fflush(stdout);

    /* Create topic */
    topic = dds_create_topic(
        participant, &TestData_Message_desc, "TestData_Message", NULL, NULL);
    if (topic < 0)
    {
        fprintf(stderr, "Error: dds_create_topic: %s\n", dds_strretcode(-topic));
        dds_delete(participant);
        return EXIT_FAILURE;
    }

    printf("=== [Subscriber] Creating reliable reader...\n");
    fflush(stdout);

    /* Create reliable reader */
    qos = dds_create_qos();
    dds_qset_reliability(qos, DDS_RELIABILITY_RELIABLE, DDS_SECS(10));
    reader = dds_create_reader(participant, topic, qos, NULL);
    if (reader < 0)
    {
        fprintf(stderr, "Error: dds_create_reader: %s\n", dds_strretcode(-reader));
        dds_delete_qos(qos);
        dds_delete(participant);
        return EXIT_FAILURE;
    }
    dds_delete_qos(qos);

    printf("\n=== [Subscriber] Waiting to receive message...\n");
    fflush(stdout);

    /* Initialize sample buffer, point void pointers in buffer array to valid sample memory locations */
    samples[0] = TestData_Message__alloc();

    int read_count = 0;
    /* Poll until data is read */
    while (true)
    {
        /* Perform actual read */
        /* Return value contains number of samples read */
        rc = dds_read(reader, samples, infos, MAX_SAMPLES, MAX_SAMPLES);
        if (rc < 0)
        {
            fprintf(stderr, "Error: dds_read: %s\n", dds_strretcode(-rc));
            TestData_Message_free(samples[0], DDS_FREE_ALL);
            dds_delete(participant);
            return EXIT_FAILURE;
        }

        /* Check if data was read and data is valid */
        if ((rc > 0) && (infos[0].valid_data))
        {
            /* Print message */
            msg = (TestData_Message *)samples[0];
            printf("=== [Subscriber] Received message: ID=%"PRId32", Content=%s\n", msg->id, msg->content);
            fflush(stdout);
            read_count++;
            
            // Exit after reading one message
            break;
        }
        else
        {
            read_count++;
            if (read_count > 500) // Wait up to 10 seconds
            {
                printf("=== [Subscriber] Timeout: No message received\n");
                break;
            }
            /* Poll wait */
            dds_sleepfor(DDS_MSECS(20));
        }
    }

    /* Free data location */
    TestData_Message_free(samples[0], DDS_FREE_ALL);

    /* Deleting participant will recursively delete all its child entities */
    rc = dds_delete(participant);
    if (rc != DDS_RETCODE_OK)
    {
        fprintf(stderr, "Error: dds_delete: %s\n", dds_strretcode(-rc));
        return EXIT_FAILURE;
    }

    printf("=== [Subscriber] Exiting\n");
    return EXIT_SUCCESS;
}


