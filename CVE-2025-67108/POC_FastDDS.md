# FastDDS Certificate Expiration Validation Vulnerability Report

## I. Vulnerability Description

eProsima Fast-DDS v3.3 was discovered to contain improper validation for ticket revocation, resulting in insecure communications and connections.

## II. Vulnerability Types

CWE-298: Improper Validation of Certificate Expiration

CWE-370: Missing Check for Certificate Revocation after Initial Check



## III. Vulnerability Analysis

### 1. Specific Code Location

The certificate expiration check is implemented in two main locations:

#### Location 1: Certificate Verification in Authentication Phase

```cpp
// ./src/cpp/security/authentication/PKIDH.cpp
static bool verify_certificate(
        X509_STORE* store,
        X509* cert,
        const bool there_are_crls)
{
    assert(store);
    assert(cert);

    bool returnedValue = false;

    X509_STORE_CTX* ctx = X509_STORE_CTX_new();

    unsigned long flags = there_are_crls ? X509_V_FLAG_CRL_CHECK : 0;
    if (X509_STORE_CTX_init(ctx, store, cert, NULL) > 0)
    {
        X509_STORE_CTX_set_flags(ctx, flags | /*X509_V_FLAG_X509_STRICT |*/
                X509_V_FLAG_CHECK_SS_SIGNATURE | X509_V_FLAG_POLICY_CHECK);

        if (X509_verify_cert(ctx) > 0)  // Line 235: Certificate validation including expiration check
        {
            returnedValue = true;
        }
        // ... error handling ...
    }
    // ... cleanup ...
    return returnedValue;
}
```

This function is called during the handshake process:

```cpp
// ./src/cpp/security/authentication/PKIDH.cpp
// Lines 1529-1533 (in begin_handshake_reply)
    if (!verify_certificate(lih->store_, rih->cert_, lih->there_are_crls_))
    {
        WARNING_SECURITY_LOGGING("PKIDH", "Error verifying certificate");
        return ValidationResult_t::VALIDATION_FAILED;
    }
```

#### Location 2: Permission Grant Validity Check

```cpp
// ./src/cpp/security/accesscontrol/Permissions.cpp
static bool is_validation_in_time(
        const Validity& validity)
{
#if _MSC_VER != 1800
    bool returned_value = false;
    std::time_t current_time = std::time(nullptr);

    if (std::difftime(current_time, validity.not_before) >= 0)
    {
        if (std::difftime(validity.not_after, current_time) >= 0)  
        {
            returned_value = true;
        }
    }

    return returned_value;
#else
    (void)validity;
    return true;
#endif // if _MSC_VER != 1800
}
```

This function is called when checking permissions:

```cpp
// ./src/cpp/security/accesscontrol/Permissions.cpp
// Lines 628-630 (in check_subject_name)
        for (auto grant : permissions.grants)
        {
            if (is_validation_in_time(grant.validity))  // Only checked during initial permission check
            {
                if (rfc2253_string_compare(grant.subject_name, lih->cert_sn_rfc2253_))
                {
                    ah->grant = std::move(grant);
                    returned_value = true;
                    // ... process grant ...
                    break;
                }
            }
        }
```

### 2. Direct Cause of the Vulnerability

The vulnerability occurs because **certificate expiration validation is only performed during the initial connection establishment phase**:

1. **During Handshake**: When a remote participant first connects, `verify_certificate()` is called in `begin_handshake_reply()` (line 1529), which uses OpenSSL's `X509_verify_cert()` to verify the certificate, including checking its expiration time.

2. **During Permission Check**: When checking permissions, `is_validation_in_time()` is called to verify that the grant's validity period is still active (line 630 in `check_subject_name()`).

3. **After Connection Established**: Once the handshake is complete and permissions are granted, **no further certificate expiration checks are performed** during ongoing communication.

## IV. Vulnerability Exploitation

### Exploitation Conditions

1. **Network Reachability**: The attacker needs to be able to establish a connection with the target FastDDS instance
2. **Certificate Authority Access**: The attacker needs access to a valid CA to sign a short-lived certificate
3. **Initial Valid Certificate**: The attacker must have a certificate that is valid at the time of connection establishment
4. **Timing Window**: The attacker needs to establish the connection before the certificate expires

### Exploitation Steps

1. **Generate Short-Lived Certificate**:
   - Create a certificate with a very short validity period (e.g., 10 seconds)
   - Sign it with a valid CA certificate
   - The certificate must be valid at the time of connection

2. **Establish Connection**:
   - Use the short-lived certificate to establish a connection with a target participant
   - During handshake, certificate validation passes (certificate is still valid)
   - Permission check passes (grant validity is still active)
   - Connection is successfully established

3. **Continue Communication After Expiration**:
   - Wait for the certificate to expire
   - Continue sending messages
   - Messages are accepted because no re-validation occurs

### Severity

This vulnerability can lead to:

1. **Security Policy Violation**: Certificates that should be invalid continue to be accepted
2. **Access Control Bypass**: Expired certificates can continue to access resources
3. **Compliance Issues**: Systems that require continuous certificate validation fail to meet compliance requirements
4. **Potential for Extended Unauthorized Access**: An attacker could establish a connection with a short-lived certificate and maintain access even after expiration

### Test Scenario

```bash
# Terminal 1: Start Publisher with short-lived certificate
./security publisher
# Output shows: "Certificate will expire at: 2025-12-12 21:30:35"
# Connection established successfully

# Wait 10+ seconds for certificate to expire

# Terminal 2: Start Subscriber
./security subscriber
# Subscriber connects and receives messages

# Publisher continues sending messages after certificate expiration
# Output shows: "[Publisher] âš  WARNING: Certificate has expired!"
# But messages are still accepted by Subscriber
```

